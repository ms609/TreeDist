
.BuildMatrix <- function(node) {
  # Internal recursive helper
  walk <- function(x) {
    if (!is.list(x)) return(list(table = matrix(0, 0, 3), root_val = -as.integer(x)))
    
    aye <- walk(x$aye)
    nay <- walk(x$nay)
    
    # aye rows start immediately after the current root (offset 1)
    # nay rows start after current root + all aye rows
    aye_offset <- 1
    nay_offset <- 1 + nrow(aye$table)
    
    # Adjust internal jump targets
    if (nrow(aye$table) > 0) {
      idx <- aye$table[, 2:3] >= 0
      aye$table[, 2:3][idx] <- aye$table[, 2:3][idx] + aye_offset
    }
    if (nrow(nay$table) > 0) {
      idx <- nay$table[, 2:3] >= 0
      nay$table[, 2:3][idx] <- nay$table[, 2:3][idx] + nay_offset
    }
    
    root_row <- c(
      as.integer(sub("sp", "", x$q)),
      if (nrow(aye$table) == 0) aye$root_val else aye_offset,
      if (nrow(nay$table) == 0) nay$root_val else nay_offset
    )
    
    return(list(
      table = rbind(root_row, aye$table, nay$table)
    ))
  }
  
  walk(node)$table
}
.CompressMatrix <- function(x) {
  repeat {
    dups <- which(duplicated(x))
    if (length(dups) == 0) break
    
    # Always merge the highest index first to keep earlier indices stable
    dup <- max(dups)
    
    # Find the first occurrence of this identical row
    duplicateOf <- which(apply(x, 1, function(row) all(row == x[dup, ])))[1]
    
    old_ptr <- dup - 1
    new_ptr <- duplicateOf - 1
    
    # Redirect pointers to the duplicate
    targets <- x[, 2:3]
    x[, 2:3][targets == old_ptr] <- new_ptr
    
    # Shift all pointers higher than the removed row down by 1
    x[, 2:3][targets > old_ptr] <- x[, 2:3][targets > old_ptr] - 1
    
    # Remove the redundant row
    x <- x[-dup, , drop = FALSE]
  }
  x
}
.FlattenMap <- function(node) {
  # 1. Recursive walk to build the raw tree matrix
  m <- .BuildMatrix(node)
  
  # 2. Iterative compression to turn the tree into a DAG
  m_compressed <- .CompressMatrix(m)
  
  # 3. Final flattening for C++ (Row-major vector)
  as.vector(t(m_compressed))
}

.EntropyTree <- function(scores, tags) {
  if (length(unique(scores)) == 1) return(scores[[1]])
  
  hJ <- apply(tags, 2, function(sp) Ntropy(table(scores, sp)))
  flag <- which.min(hJ)
  
  has <- tags[, flag]
  if (all(has)) stop("Splitting on allT - fail")
  if (all(!has)) stop("Splitting on allF - fail")
  
  .Retain <- function(rows) {
    ret <- tags[rows, -flag, drop = FALSE]
    cs <- colSums(ret)
    ret[, cs > 0 & cs < dim(ret)[[1]], drop = FALSE]
  }
  
  list(
    q = names(flag),
    aye = .EntropyTree(scores[has], .Retain(has)),
    nay = .EntropyTree(scores[!has], .Retain(!has))
  )
}


PAMap <- function(splits) {
  ids <- sort(unique(as.integer(splits)))
  `colnames<-`(
    vapply(ids, function(id) apply(splits, 2, function(r) id %in% r),
           logical(ncol(splits))),
    paste0("sp", ids)
  )
}


# tree_vec: The flat integer vector generated by .FlattenMapPure
# present_splits: A vector of integers (e.g., c(13, 15, 48)) 
#                 representing the splits found in the current case.
DebugWalkTree <- function(tree_vec, present_splits) {
  # Convert present_splits to a logical lookup for speed (like our char array)
  lookup <- logical(256)
  lookup[present_splits + 1] <- TRUE # +1 because R is 1-indexed
  
  cursor <- 0
  path <- c() # To track our steps for debugging
  
  while (TRUE) {
    base <- (cursor * 3) + 1 # +1 for R indexing
    
    split_idx <- tree_vec[base]
    aye_target <- tree_vec[base + 1]
    nay_target <- tree_vec[base + 2]
    
    # Log the step
    is_present <- lookup[split_idx + 1]
    path <- c(path, sprintf("Node %d: (sp%d is %s)", cursor, split_idx, is_present))
    
    # Decide next step
    next_node <- if (is_present) aye_target else nay_target
    
    if (next_node < 0) {
      cat("Path taken:\n", paste(path, collapse = " -> "), "\n")
      return(list(result = -next_node, path = path))
    }
    
    cursor <- next_node
  }
}

CheckMap <- function(map, splits, scores, valid) {
  flat <- .FlattenMap(map)
  for (i in seq_len(sum(valid))) {
    message(paste0(splits[, i], collapse = "-"))
    expect_equal(DebugWalkTree(flat, splits[, i])$result,
                 scores[valid][i])
  }
}

# Generate the C++ definition
DecisionTreeLine <- function(name, scores, valid, splits) {
  map <- .EntropyTree(scores[valid], PAMap(splits))
  flat <- .FlattenMap(map)
  sprintf("inline constexpr int %s7_SCORES[] = {%s};", 
          name, paste(flat, collapse = ","))
}
