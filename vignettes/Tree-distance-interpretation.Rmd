---
title: "Interpreting tree distance metrics"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Interpreting tree distance metrics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, echo=FALSE, warning=FALSE}
standardMargin <- c(0.4, 0.4, 0.8, 0.4)
cbPalette8 <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
                "#0072B2", "#D55E00", "#CC79A7")
```

## Expected values for random trees

Context for tree distances can be provided by comparison with the
distance expected for a pair of random trees. 

The figure below shows how the median normalized tree distance varies with the 
number of leaves in the trees being compared.
1&nbsp;000 random pairs of $n$-leaf trees were generated for
$4 \leq n \leq 200$`r ''#4 &le; _n_ &le; 200`,
and the distances between them calculated.
Shaded envelopes denote the interdecile and interquartile ranges.
The raw data are available in the data object 
[`randomTreeDistances`](https://ms609.github.io/TreeDistData/reference/randomTreeDistances.html)
in the R package
'[TreeDistData](https://ms609.github.io/TreeDistData)'.


```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=2, fig.width=6, fig.align='center'}
if (requireNamespace('TreeDistData', quietly = TRUE)) {
  library('TreeDistData')
  data('tdMethods', package = 'TreeDistData')
  data('tdAbbrevs', package = 'TreeDistData')
  methods <- tdMethods
  abbrevs <- tdAbbrevs
  
  totalInfoContent <- 3L
  methodLCH <- colorspace::coords(as(colorspace::hex2RGB(TreeDistCol(methods)), 'polarLUV'))
  
  data('randomTreeDistances', package = 'TreeDistData')
  pathMax <- randomTreeDistances['path', 'max', ]
  msMax <- randomTreeDistances['ms', 'max', ]
  nniMax <- randomTreeDistances['nni_u', 'max', ]
  tbrMax <- randomTreeDistances['tbr_u', 'max', ]
  
  nTip <- as.integer(dimnames(randomTreeDistances)[[3]])
  
  pathNorm <- nls(pathMax ~ a * (nTip ^ 2) + b * (nTip ^ 3) + nTip ^ c,
                  start = list(a = -0.0334, b = 2.6e-5, c = 1.478))
  
  msNorm <- nls(msMax ~ (c * nTip ^ b) + d, 
                start = list(b = 1.314521, c = 2.365871, d = -34.24))
  
  #tbrNorm <- lm(log(tbrMax) ~ log(nTip))
  nniNorm <- TreeDist::NNIDiameter(nTip)
  
  normalizeAgainst <- rbind(
    path = predict(pathNorm),
    ms = predict(msNorm),
    nni_u = nniNorm[, 'max'],
    nni_l = nniNorm[, 'min'],# nTip - 3, # Each edge once
    spr = nTip / 2L,
    tbr_u = nTip, #exp(predict(tbrNorm)),
    tbr_l = nTip, #exp(predict(tbrNorm)),
    rf = (nTip - 3L) * 2L,
    mast = nTip,
    masti = TreeTools::LnUnrooted(nTip) / log(2)
  )
  
  AddLine <- function (method, normalize = FALSE) {
    dat <- randomTreeDistances[method, , ]
    dat <- dat[, !is.na(dat[1, ])]
    nLeaves <- colnames(dat)
    if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each = dim(dat)[1L])
    Invert <- function (dat) {
      dat['mean', ] <- 1 - dat['mean', ]
      dat[c("min", "1%", "5%", "10%", "25%", "50%", "75%", "90%", "95%", 
            "99%", "max"), ] <- 1 - 
        dat[c("max", "99%", "95%", "90%", "75%", "50%", "25%", 
              "10%", "5%", "1%", "min"), ]
      dat
    }
    if (method %in% c('mast', 'masti')) dat <- Invert(dat)
    
    col <- TreeDistCol(method, '')
    
    lines(nLeaves, dat['50%', ], pch = 1, col = col)
    polygon(c(nLeaves, rev(nLeaves)), c(dat['10%', ], rev(dat['90%', ])),
            border = NA, col = paste0(col, '33'),)
    polygon(c(nLeaves, rev(nLeaves)), c(dat['25%', ], rev(dat['75%', ])),
            border = NA, col = paste0(col, '33'),)
    #lines(nLeaves, dat['25%', ], lty = 2, col = col)
    #lines(nLeaves, dat['75%', ], lty = 2, col = col)
    #pointsAt <- 1:10 * 20L
  }
  
  oldPar <- par(mfrow = c(3, 1), cex = 0.7, oma = rep(0, 4),
                mar = c(5, 5, 0.01, 0.01))
  PlotMethods <- function (methods, yMin = 0.4,
                           lp = c('bottomright', 'bottomleft')) {
    plot(as.integer(dimnames(randomTreeDistances)[[3]]),
         randomTreeDistances['pid', 'mean', ],
         ylim = c(yMin, 1), type = 'n',
         xlab = "Number of leaves", ylab = "Normalized tree distance")
    for (method in methods) AddLine(method, 
                                    method %in% c('ms', rownames(normalizeAgainst)))
    
    
    legend(lp[1], bty = 'n',
           lty = 1, legend = abbrevs[methods], col = TreeDistCol(methods, 44),
           text.col = '#FFFFFFFF', pch = 15, pt.cex = 1.8
    )
    
    legend(lp[1], bty = 'n', lty = 1, 
           legend = abbrevs[methods], col = TreeDistCol(methods))
    
    legend(lp[2], bty = 'n', inset = c(0.09, 0),
           lty = 1, lwd = c(1, 4, 6), col = c(1, "#00000066", "#00000033"),
           legend = c('Median', 'Interquartile range', 'Interdecile range'))
  }
  PlotMethods(c('rf', 'pid', 'cid', 'ms', 'nye', 'msid'))
  PlotMethods(c('rf', 'jnc4', 'jco4', 'jnc2', 'jco2', 'nye'), yMin = 0.7)
  PlotMethods(c('tbr_u', 'spr', 'nni_u', 'nni_l', 'masti', 'mast',
                'path', 'qd', 'tbr_l'), yMin = 0.14, 
              lp = c('bottomright', 'right'))
  par(oldPar)
} else {
  cat("\nInstall package 'TreeDistData' to render this chart.")
}
```


Information-based metrics are normalized against the total information content 
of each pair of trees. 
The (Jaccard-)Robinson-Foulds, Nye _et al._, maximum agreement subtree and 
Quartet metrics are normalized based on the maximum possible value. 
The SPR distance is normalized against $\frac{n}{2}$; this value lies between 
the definitive bounds of the maximum diameter of the SPR distance [@Allen2001],
and was not exceeded by any of the random tree pairs.  The TBR distance is 
normalized against $n$; the lower bound of the NNI distance is normalized
against the number of internal edges in an unrooted _n_-leaf tree, $n - 3$.
The upper bound of the NNI distance is normalized by fitting a log-linear model
to the maximum observed distance for each number of leaves (using 
`lm(log(maxDistance) ~ log(nLeaves))`).

The path and Matching Split Distance metrics do not have a 
readily calculated maximum value and are thus crudely 'normalized' against an
approximate maximum, estimated by fitting a polynomial to the the maximum 
observed distance for each number of leaves.  Candidate polynomial functions
were evaluated based on the Akaike and Bayesian information criteria.

Note that the path and Matching Splits distances exhibit a prominently larger 
variability than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.  In combination with the 
difficulty in calculating the range of these metrics, this makes their 
absolute value difficult to interpret.

## References
