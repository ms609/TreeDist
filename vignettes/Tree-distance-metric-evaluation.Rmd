---
title: "Interpreting tree distance metrics"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    includes:
      in_header: ../inst/preamble.tex
  rmarkdown::html_document:
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl

vignette: >
  %\VignetteIndexEntry{Tree distance metric evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, echo=FALSE, warning=FALSE}
standardMargin <- c(0.4, 0.4, 0.8, 0.4)
cbPalette8 <- Ternary::cbPalette8
```

## Expected values for random trees

Context for tree distances can be provided by comparison with the
distance expected for a pair of random trees. 

The figure below shows how the median normalized tree distance varies with the 
number of terminals in the trees being compared.
1&nbsp;000 random pairs of _n_-terminal trees were generated for
$4 \leq n \leq 200$`r ''#4 &le; _n_ &le; 200`,
and the distances between them calcuated.
Shaded envelopes denote the interdecile and interquartile ranges.
The raw data are available in the data object 
`randomTreeDistances` in the R package
[`TreeDistData`](https://github.com/ms609/TreeDistData).

Information-based metrics are normalized against the total 
information content of each pair of trees. 
The Robinson-Foulds, Nye _et al._ and Quartet metrics 
are normalized based on the maximum possible value. 
The SPR distance is normalized against _n_ / 2; this value lies between the 
definitive bounds of the maximum diameter of the SPR distance [@Allen2001],
and was not exceeded by any of the random tree pairs.
The path and Matching Split Distance metrics do not have a readily calculated
maximum value and are thus crudely 'normalized' against an approximate maximum, 
estimated by curve-fitting the maximum observed distance for each number of
terminals.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, fig.align='center'}
if (require('TreeDistData')) {
  methods <- c('vpi', 'vmsi', 'vci', 'qd', 'nts', 'ja2', 'ja4', 'jna2', 'jna4',
                'msd', 'mast', 'masti',
                'nni_l', 'nni_t', 'nni_u', 'spr', 'tbr_l', 'tbr_u',
                'rf', 'path')
  plotSequence <- c('vpi', 'vmsi', 'vci', 'qd', 'nts', 'ja2', 'ja4', 'jna2', 'jna4',
                'msd', 'mast', 'masti',
                'nni_l', 'nni_t', 'nni_u', 'spr', 'tbr_l', 'tbr_u',
                'rf', 'path')
  legendSequence <- c('vpi', 'vmsi', 'vci', 'qd', 'nts', 'ja2', 'ja4', 'jna2', 'jna4',
                'msd', 'mast', 'masti',
                'nni_l', 'nni_t', 'nni_u', 'spr', 'tbr_l', 'tbr_u',
                'rf', 'path')
  abbrevs <- c(
  rf  = 'Robinson-Foulds',
  rfi = 'Robinson-Foulds Info',

  ja2 = 'JRF (k=2, arboreal)',
  ja4 = 'JRF (k=4, arboreal)',
  jna2 = 'JRF (k=2, non-arb.)',
  jna4 = 'JRF (k=4, non-arb.)',

  vpi = 'Var. Phylog. Info',
  nni = 'NNI (approx.)',
  nni_u = 'NNI (upr bnd)',
  nni_t = 'NNI (ub tight)',
  nni_l = 'NNI (lwr bnd)',
  spr = 'SPR (approx.)',

  tbr = 'TBR (approx.)',
  tbr_l = 'TBR (lb approx.)',
  tbr_u = 'TBR (ub approx.)',
  mafi = 'MAF info',
  path = 'Path',
  mst = 'MAST',
  mast = 'MAST size',
  masti = 'MAST info',
  vci = 'Var. Clust. Info',

  nea = 'Nye et al.',
  nts = expression(paste(plain('Nye '), italic('et al.'))),
  qd  = 'Quartet',
  vmsi = 'Var. Matching Split Info',
  msd = 'Match. Split Dist.'
)[methods]
  tableau20 <- c('#4e78a8', '#A0CBE8',
               '#f28e2c', '#FFBE7D',
               '#59a14f', '#8CD17D',
               '#B6992D', '#F1CE63',
               '#499894', '#86BCB6',
               '#E15759', '#FF9D9A',
               '#79706E', '#BAB0AC',
               '#D37295', '#FABFD2',
               '#B07AA1', '#D4A6C8',
               '#9D7660', '#D7B5A6',
               '#000000','#000000','#000000','#000000','#000000','#000000','#000000',
               '#000000'
               )
# https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
# https://jrnold.github.io/ggthemes/reference/tableau_color_pal.html

  methodCol <- tableau20[c((1:10 * 2 - 1L), (seq_len(length(methods) - 10L) * 2))]
  
  totalInfoContent <- 3L
  maxPossible <- 6L
  maxObserved <- 4L
  methodPch <- c(vci = totalInfoContent, vpi = totalInfoContent, 
                 rf = maxPossible, nts = maxPossible, qd = maxPossible,
                 path = maxObserved, 
                 msd = maxObserved)
  names(methodCol) <- names(abbrevs)
  methodCol <- methodCol[methods]
  methodPch <- methodPch[methods]
  methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))
  
  
  
  
  data('randomTreeDistances', package='TreeDistData')
  
  pathMax <- randomTreeDistances['path', 'max', ]
  msdMax <- randomTreeDistances['msd', 'max', ]
  
  nTip <- as.integer(names(pathMax))
  
  pathNorm <- nls(pathMax ~ a * (nTip ^2) + b * (nTip ^3) + nTip ^ c,
                 start = list(a = -0.034, b = 4e-5, c = 1.44))
  # loess(pathMax ~ nTip) is Unsuitable for small _n_
  msdNorm <- nls(msdMax ~ (a * nTip) + (c * nTip ^ b) + d,
                start = list(a = -29.185, b=1.094, c = 24.85, d = 6))
  # msdNorm is a worse AIC/BIC with the d term, but visually better at small n
  
  normalizeAgainst <- rbind(
    path = predict(pathNorm),
    msd = predict(msdNorm)
  )
  
  AddLine <- function (method, normalize = FALSE) {
    dat <- randomTreeDistances[method, , ]
    dat <- dat[, !is.na(dat[1, ])]
    nLeaves <- colnames(dat)
    if (method == 'spr') {
      dat <- vapply(nLeaves, function (n) (as.integer(n) - 3L) * dat[, n] /
                      (as.integer(n) / 2L), double(13))
    }
    if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each=dim(dat)[1L])
    col <- methodCol[method]
    pch <- methodPch[method]
  
    #points(nLeaves, dat['mean', ], pch=pch, col=col)
    lines(nLeaves, dat['50%', ], pch=1, col=col)
    polygon(c(nLeaves, rev(nLeaves)), c(dat['10%', ], rev(dat['90%', ])),
            border=NA, col = paste0(col, '33'),)
    polygon(c(nLeaves, rev(nLeaves)), c(dat['25%', ], rev(dat['75%', ])),
            border=NA, col = paste0(col, '33'),)
    #lines(nLeaves, dat['25%', ], lty=2, col=col)
    #lines(nLeaves, dat['75%', ], lty=2, col=col)
    #pointsAt <- 1:10 * 20L
    #points(pointsAt, dat['50%', as.character(pointsAt)], col=col, pch=pch)
  }
  
  par(cex = 0.7)
  par(oma=rep(0, 4))
  par(mar=c(5, 5, 0.01, 0.01))
  plot(as.integer(dimnames(randomTreeDistances)[[3]]),
       randomTreeDistances['vpi', 'mean', ],
       ylim=c(0.4, 1), type='n',
       xlab = "Number of terminals", ylab = "Normalized tree distance")
  for (method in methods) AddLine(method, method %in% c('msd', 'path'))
  
  
  legend('bottomright', bty='n',
         lty=1, legend=abbrevs, col=paste0(methodCol, 44), text.col='#FFFFFFFF',
         pch = 15, pt.cex=1.8
  )
  
  legend('bottomright', bty='n',
         lty=1, legend=abbrevs, col=methodCol,
         )
  
  legend('bottomleft', bty='n', inset=c(0.09, 0),
         lty=1, lwd = c(1, 4, 6), col=c(1, "#00000066", "#00000033"),
         legend=c('Median', 'Interquartile range', 'Interdecile range'))
} else {
  cat("\nInstall package `TreeDistData` to render this chart.")
}
```

Note that the path and Matching Splits distances exhibit a prominently larger 
variability than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.  In combination with the 
difficulty in calculating the range of these metrics, this makes their 
absolute value difficult to interpret.

# References
