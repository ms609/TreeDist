---
title: "Evaluating tree distance metrics"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    includes:
      in_header: ../inst/preamble.tex
  rmarkdown::html_document:
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl

vignette: >
  %\VignetteIndexEntry{Tree distance metric evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, echo=FALSE, warning=FALSE}
standardMargin <- c(0.4, 0.4, 0.8, 0.4)
cbPalette8 <- Ternary::cbPalette8
```

# Interpretability

## Unit equivalence

A further shortcoming of the RF metric is that not all partitions represent an equivalent amount of information.  A partition distance of 1 could mean that two trees differ in an less informative partition, or a more informative partition.  All quartets,
in contrast, are equally informative.

Consider a balanced and an unbalanced eight-taxon tree:

```{r two-trees, echo=FALSE, fig.height = 3, fig.width=6}
par(mfrow=c(1, 2), mar=standardMargin, cex=0.9)
plot(balancedTree <- ape::read.tree(text="(((a, b), (c, d)), ((e, f), (g, h)));"),
     edge.color = cbPalette8[3])
ape::edgelabels(1:5, c(1, 2, 5, 9, 12))
legend('topleft', 'Balanced tree', bty='n')

plot(caterpillarTree <- ape::read.tree(text="(a, (b, (c, (d, (e, (f, (g, h)))))));"),
     edge.color = cbPalette8[2])
ape::edgelabels(1:5, c(4, 6, 8, 10, 12))
legend('topleft', 'Asymmetric tree', bty='n')
```

Each tree divides the eight taxa into five bipartition splits.  
The information content (Shannon entropy) of a split can be calculated based on 
what proportion of eight-tip trees contain the split in question. 
This is a function of the evenness of the split:

```{r ic-of-splits, display='asis', echo=FALSE, warnings=FALSE}
splitSmall <- 2:4
splitLarge <- 8L - splitSmall

rootedTrees <- c(
  '1' = 1,
  '2' = 1 * 1,
  '3' = 3 * 1,
  '4' = 5 * 3 * 1,
  '5' = 7 * 5 * 3 * 1,
  '6' = 9 * 7 * 5 * 3 * 1
)

matchingTrees <- rootedTrees[splitSmall] * rootedTrees[splitLarge]
names(matchingTrees) <- paste0("Partition size: ", splitSmall, ':', splitLarge)

matchingP <- matchingTrees / (11 * 9 * 7 * 5 * 3 * 1 * 1)

ic <- -log(matchingP) / log(2)

knitr::kable(cbind(
      'Matching trees' = matchingTrees,
      'p(Match in random tree)' = signif(matchingP, 3),
      'Information content / bits' = ic))
```

In the first tree, split 1 is even, dividing four taxa from four others (`4:4`); splits 2--5 are maximally uneven (`2:6`).  The total information content of these five splits is `r signif(sum(ic[c(4, 2, 2, 2, 2) - 1]), 4)`, whereas that of the five splits in 
the second tree, of sizes `2:6`, `3:5`, `4:4`, `3:5` and `2:6`, is
`r signif(sum(ic[c(2, 3, 4, 3, 2) - 1]), 4)`. Put another way, a random tree will
on average share more partitions with the balanced tree (whose partitions are 
predominantly uneven and thus likely to be matched) than the asymmetric tree 
(which contains more even partitions that are less likely to occur in a random tree).

Of the 10&nbsp;395 eight-tip trees, many more bear at least one partition in 
common with a balanced tree than with an asymmetric tree, whereas the distribution of quartets is identical:

```{r all-8-tip-trees, echo=FALSE, cache=TRUE}
#calculate <- FALSE
#if (calculate) {
#  all8 <- phytools::allFurcTrees(8, letters[1:8], FALSE)
#  allBif8 <- all8[vapply(all8, function(x) x$Nnode, 1L) == 6]
#  inBalanced <- SplitStatus(allBif8, balancedTree)[, 's']
#  inCaterpillar <- SplitStatus(allBif8, caterpillarTree)[, 's']
#  qInBalanced <- Quartet::QuartetStatus(allBif8, balancedTree)[, 's']
#  qInCaterpillar <- Quartet::QuartetStatus(allBif8, balancedTree)[, 's']
#} else {
  inBalanced <- rep(0:5, c(7088, 2708, 512, 76, 10, 1))
  inCaterpillar <- rep(0:5, c(8162, 1808, 350, 64, 10, 1))
  qInBalanced <- qInCaterpillar <- rep(c(10:42, 44:46, 49, 50, 53, 54, 57, 62, 70),
    c(32, 256, 512, 384, 512, 320, 512, 448, 512, 512, 688, 160, 512, 448, 256, 464, 416, 448, 576, 256, 192, 320, 160, 288, 128, 192, 132, 80, 32, 32, 224, 64, 8, 64, 112, 16, 64, 16, 4, 18, 16, 8, 1))
#}

par(mfrow=c(1, 2), cex=0.8)
plot.new()
plot.window(main='8-tip trees with N common splits', cex.main=1,
            xlim=c(0, 6), ylim=c(0, 2708),
            xlab='Splits in common', ylab='Number of trees')
sch <- hist(inCaterpillar + 0.5, breaks = 0:12 / 2 - 0.0001, plot=FALSE)
sbh <- hist(inBalanced, breaks = 0:12 / 2 - 0.0001, plot=FALSE)
plot(sch, col=paste0(cbPalette8[2], '44'), add=TRUE)
plot(sbh, col=paste0(cbPalette8[3], '44'), add=TRUE)
text(0.0, 100, paste0('Balanced: ', sum(inBalanced == 0)), pos=4, srt=90, cex=0.7)
text(0.5, 100, paste0('Asymmetric: ', sum(inCaterpillar == 0)), pos=4, srt=90, cex=0.7)

legend('topright', pch=22,
       pt.cex = 2, col='black',
       pt.bg = paste0(cbPalette8[2:3], '44'), bty='n',
       c('Asymmetric', 'Balanced'))
axis(1, at=0:5 + 0.5, labels=0:5)
axis(2)

qch <- hist(qInCaterpillar, breaks = 0:36 * 2 - 0.0001, plot=FALSE)
qbh <- hist(qInBalanced,    breaks = 0:36 * 2 - 0.0001, plot=FALSE)

plot(qch, col=paste0(cbPalette8[2], '44'), main='8-tip trees with N common quartets',
     xlab='Quartets in common', ylab='Number of trees', axes=FALSE, cex.main=1)
plot(qbh, col=paste0(cbPalette8[3], '44'), add=TRUE)
axis(1, at=0:36 * 2, labels=(0:36) * 2)
axis(2)

```

This differing information content is reflected in the ranges taken by
explicitly information-theoretic measures of tree similarity.  
This behaviour occurs because the information theoretic measures (including
the quartet divergence) have units of bits, rather than arbitrary units.
This said, although the range of the information-based equivalent to the 
matching splits distance matches that of the mutual phylogenetic information,
it is not clear that the calculated information content of non-arboreal
matches is a natural value.

## Expected values for random trees

Context for tree distances can be provided by comparison with the
distance expected for a pair of random trees. 

The figure below shows how the median normalized tree distance varies with the 
number of terminals in the trees being compared.
1&nbsp;000 random pairs of _n_-terminal trees were generated for
$4 \leq n \leq 200$`r ''#4 &le; _n_ &le; 200`,
and the distances between them calcuated.
Shaded envelopes denote the interdecile and interquartile ranges.
The raw data are available in the data object 
`randomTreeDistances` in the R package
[`TreeDistData`](https://github.com/ms609/TreeDistData).

Information-based metrics are normalized against the total 
information content of each pair of trees. 
The Robinson-Foulds, Nye _et al._ and Quartet metrics 
are normalized based on the maximum possible value. 
The SPR distance is normalized against _n_ / 2; this value lies between the 
definitive bounds of the maximum diameter of the SPR distance [@Allen2001],
and was not exceeded by any of the random tree pairs.
The path and Matching Split Distance metrics do not have a readily calculated
maximum value and are thus crudely 'normalized' against an approximate maximum, 
estimated by curve-fitting the maximum observed distance for each number of
terminals.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, fig.align='center'}
methods <- c('rf', 'spr', 'vpi', 'vci', 'msd', 'nts', 'path', 'qd', 'vmsi')
plotSequence <- c('vpi', 'vci', 'nts', 'qd', 'msd', 'path', 'spr', 'rf')
legendSequence <- c('vpi', 'vci', 'vmsi', 'nts', 'msd', 'qd', 'path', 'spr', 'rf')
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vpi = 'Var. Phylog. Info',
  spr = 'SPR',
  path = 'Path',
  vci = 'Var. Clust. Info', 
  nts = expression(paste(plain('Nye '), italic('et al.'))),
  qd  = 'Quartet',
  vmsi = 'V. Match. Split Inf.',
  msd = 'Match. Split Dist.'
)[methods]
methodCol <- c(
'#4e78a8',
'#f28e2c',
'#e15659',
'#75b7b2',
'#58a14e',
'#edc949',
'#af7aa1',
'#fd9da7',
'#9d745f',
'#bab0ac')[1:9] # https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782

totalInfoContent <- 3L
maxPossible <- 6L
maxObserved <- 4L
methodPch <- c(vci = totalInfoContent, vpi = totalInfoContent, 
               rf = maxPossible, nts = maxPossible, qd = maxPossible,
               path = maxObserved, 
               msd = maxObserved)
names(methodCol) <- names(abbrevs)
methodCol <- methodCol[methods]
methodPch <- methodPch[methods]
methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))




data('randomTreeDistances', package='TreeDistData')

pathMax <- randomTreeDistances['path', 'max', ]
msdMax <- randomTreeDistances['msd', 'max', ]

nTip <- as.integer(names(pathMax))

pathNorm <- nls(pathMax ~ a * (nTip ^2) + b * (nTip ^3) + nTip ^ c,
               start = list(a = -0.034, b = 4e-5, c = 1.44))
# loess(pathMax ~ nTip) is Unsuitable for small _n_
msdNorm <- nls(msdMax ~ (a * nTip) + (c * nTip ^ b) + d,
              start = list(a = -29.185, b=1.094, c = 24.85, d = 6))
# msdNorm is a worse AIC/BIC with the d term, but visually better at small n

normalizeAgainst <- rbind(
  path = predict(pathNorm),
  msd = predict(msdNorm)
)

AddLine <- function (method, normalize = FALSE) {
  dat <- randomTreeDistances[method, , ]
  dat <- dat[, !is.na(dat[1, ])]
  nLeaves <- colnames(dat)
  if (method == 'spr') {
    dat <- vapply(nLeaves, function (n) (as.integer(n) - 3L) * dat[, n] /
                    (as.integer(n) / 2L), double(13))
  }
  if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each=dim(dat)[1L])
  col <- methodCol[method]
  pch <- methodPch[method]

  #points(nLeaves, dat['mean', ], pch=pch, col=col)
  lines(nLeaves, dat['50%', ], pch=1, col=col)
  polygon(c(nLeaves, rev(nLeaves)), c(dat['10%', ], rev(dat['90%', ])),
          border=NA, col = paste0(col, '33'),)
  polygon(c(nLeaves, rev(nLeaves)), c(dat['25%', ], rev(dat['75%', ])),
          border=NA, col = paste0(col, '33'),)
  #lines(nLeaves, dat['25%', ], lty=2, col=col)
  #lines(nLeaves, dat['75%', ], lty=2, col=col)
  #pointsAt <- 1:10 * 20L
  #points(pointsAt, dat['50%', as.character(pointsAt)], col=col, pch=pch)
}

par(cex = 0.7)
par(oma=rep(0, 4))
par(mar=c(5, 5, 0.01, 0.01))
plot(as.integer(dimnames(randomTreeDistances)[[3]]),
     randomTreeDistances['vpi', 'mean', ],
     ylim=c(0.4, 1), type='n',
     xlab = "Number of terminals", ylab = "Normalized tree distance")
for (method in methods) AddLine(method, method %in% c('msd', 'path'))


legend('bottomright', bty='n',
       lty=1, legend=abbrevs, col=paste0(methodCol, 44), text.col='#FFFFFFFF',
       pch = 15, pt.cex=1.8
)

legend('bottomright', bty='n',
       lty=1, legend=abbrevs, col=methodCol,
       )

legend('bottomleft', bty='n', inset=c(0.09, 0),
       lty=1, lwd = c(1, 4, 6), col=c(1, "#00000066", "#00000033"),
       legend=c('Median', 'Interquartile range', 'Interdecile range'))

```

Note that the path and Matching Splits distances exhibit a prominently larger 
variability than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.  In combination with the 
difficulty in calculating the range of these metrics, this makes their 
absolute value difficult to interpret.

# References
