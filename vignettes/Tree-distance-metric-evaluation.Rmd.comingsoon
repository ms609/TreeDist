---
title: "Evaluating tree distance metrics"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: 
  bookdown::pdf_document2:
    includes:
      in_header: ../inst/preamble.tex
  rmarkdown::html_document:
bibliography: ../inst/REFERENCES.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-old-doi-prefix.csl

vignette: >
  %\VignetteIndexEntry{Tree distance metric evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, echo=FALSE, warning=FALSE}
standardMargin <- c(0.4, 0.4, 0.8, 0.4)
cbPalette8 <- Ternary::cbPalette8
```

# Interpretability

## Expected values for random trees

Context for tree distances can be provided by comparison with the
distance expected for a pair of random trees. 

The figure below shows how the median normalized tree distance varies with the 
number of terminals in the trees being compared.
1&nbsp;000 random pairs of _n_-terminal trees were generated for
$4 \leq n \leq 200$`r ''#4 &le; _n_ &le; 200`,
and the distances between them calcuated.
Shaded envelopes denote the interdecile and interquartile ranges.
The raw data are available in the data object 
`randomTreeDistances` in the R package
[`TreeDistData`](https://github.com/ms609/TreeDistData).

Information-based metrics are normalized against the total 
information content of each pair of trees. 
The Robinson-Foulds, Nye _et al._ and Quartet metrics 
are normalized based on the maximum possible value. 
The SPR distance is normalized against _n_ / 2; this value lies between the 
definitive bounds of the maximum diameter of the SPR distance [@Allen2001],
and was not exceeded by any of the random tree pairs.
The path and Matching Split Distance metrics do not have a readily calculated
maximum value and are thus crudely 'normalized' against an approximate maximum, 
estimated by curve-fitting the maximum observed distance for each number of
terminals.

```{R Tree-distance-averages, echo=FALSE, message=FALSE, cache=TRUE, fig.asp=1, fig.width=6, fig.align='center'}
methods <- c('rf', 'spr', 'vpi', 'vci', 'msd', 'nts', 'path', 'qd', 'vmsi')
plotSequence <- c('vpi', 'vci', 'nts', 'qd', 'msd', 'path', 'spr', 'rf')
legendSequence <- c('vpi', 'vci', 'vmsi', 'nts', 'msd', 'qd', 'path', 'spr', 'rf')
abbrevs <- c(
  rf  = 'Robinson-Foulds',
  vpi = 'Var. Phylog. Info',
  spr = 'SPR',
  path = 'Path',
  vci = 'Var. Clust. Info', 
  nts = expression(paste(plain('Nye '), italic('et al.'))),
  qd  = 'Quartet',
  vmsi = 'V. Match. Split Inf.',
  msd = 'Match. Split Dist.'
)[methods]
methodCol <- c(
'#4e78a8',
'#f28e2c',
'#e15659',
'#75b7b2',
'#58a14e',
'#edc949',
'#af7aa1',
'#fd9da7',
'#9d745f',
'#bab0ac')[1:9] # https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782

totalInfoContent <- 3L
maxPossible <- 6L
maxObserved <- 4L
methodPch <- c(vci = totalInfoContent, vpi = totalInfoContent, 
               rf = maxPossible, nts = maxPossible, qd = maxPossible,
               path = maxObserved, 
               msd = maxObserved)
names(methodCol) <- names(abbrevs)
methodCol <- methodCol[methods]
methodPch <- methodPch[methods]
methodLCH <- colorspace::coords(as(colorspace::hex2RGB(methodCol), 'polarLUV'))




data('randomTreeDistances', package='TreeDistData')

pathMax <- randomTreeDistances['path', 'max', ]
msdMax <- randomTreeDistances['msd', 'max', ]

nTip <- as.integer(names(pathMax))

pathNorm <- nls(pathMax ~ a * (nTip ^2) + b * (nTip ^3) + nTip ^ c,
               start = list(a = -0.034, b = 4e-5, c = 1.44))
# loess(pathMax ~ nTip) is Unsuitable for small _n_
msdNorm <- nls(msdMax ~ (a * nTip) + (c * nTip ^ b) + d,
              start = list(a = -29.185, b=1.094, c = 24.85, d = 6))
# msdNorm is a worse AIC/BIC with the d term, but visually better at small n

normalizeAgainst <- rbind(
  path = predict(pathNorm),
  msd = predict(msdNorm)
)

AddLine <- function (method, normalize = FALSE) {
  dat <- randomTreeDistances[method, , ]
  dat <- dat[, !is.na(dat[1, ])]
  nLeaves <- colnames(dat)
  if (method == 'spr') {
    dat <- vapply(nLeaves, function (n) (as.integer(n) - 3L) * dat[, n] /
                    (as.integer(n) / 2L), double(13))
  }
  if (normalize) dat <- dat / rep(normalizeAgainst[method, ], each=dim(dat)[1L])
  col <- methodCol[method]
  pch <- methodPch[method]

  #points(nLeaves, dat['mean', ], pch=pch, col=col)
  lines(nLeaves, dat['50%', ], pch=1, col=col)
  polygon(c(nLeaves, rev(nLeaves)), c(dat['10%', ], rev(dat['90%', ])),
          border=NA, col = paste0(col, '33'),)
  polygon(c(nLeaves, rev(nLeaves)), c(dat['25%', ], rev(dat['75%', ])),
          border=NA, col = paste0(col, '33'),)
  #lines(nLeaves, dat['25%', ], lty=2, col=col)
  #lines(nLeaves, dat['75%', ], lty=2, col=col)
  #pointsAt <- 1:10 * 20L
  #points(pointsAt, dat['50%', as.character(pointsAt)], col=col, pch=pch)
}

par(cex = 0.7)
par(oma=rep(0, 4))
par(mar=c(5, 5, 0.01, 0.01))
plot(as.integer(dimnames(randomTreeDistances)[[3]]),
     randomTreeDistances['vpi', 'mean', ],
     ylim=c(0.4, 1), type='n',
     xlab = "Number of terminals", ylab = "Normalized tree distance")
for (method in methods) AddLine(method, method %in% c('msd', 'path'))


legend('bottomright', bty='n',
       lty=1, legend=abbrevs, col=paste0(methodCol, 44), text.col='#FFFFFFFF',
       pch = 15, pt.cex=1.8
)

legend('bottomright', bty='n',
       lty=1, legend=abbrevs, col=methodCol,
       )

legend('bottomleft', bty='n', inset=c(0.09, 0),
       lty=1, lwd = c(1, 4, 6), col=c(1, "#00000066", "#00000033"),
       legend=c('Median', 'Interquartile range', 'Interdecile range'))

```

Note that the path and Matching Splits distances exhibit a prominently larger 
variability than other metrics, suggesting that they are less consistent in the
score that they assign to a random pair of trees.  In combination with the 
difficulty in calculating the range of these metrics, this makes their 
absolute value difficult to interpret.

# References
