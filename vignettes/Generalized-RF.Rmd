---
title: "Generalized Robinson-Foulds distances"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Generalized Robinson-Foulds distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, message=FALSE, warning=FALSE, echo = FALSE}
library('ape')
library('TreeDist')
tree1 <- read.tree(text='((A, B), ((C, (D, E)), (F, (G, (H, I)))));')
tree2 <- read.tree(text='((A, B), ((C, D, (E, I)), (F, (G, H))));')
AtoJ <-  read.tree(text='(((((A, B), C), D), E), (F, (G, (H, (I, J)))));')
AotJ <-  read.tree(text='(((((J, B), C), D), E), (F, (G, (H, (I, A)))));')
```

This document outlines the similarity measures employed by the 
generalized Robinson-Foulds distances implemented in this package.

Generalized RF distances are introduced [elsewhere](Robinson-Foulds.html); 
before you read further, you may also wish to revisit how to
[use the TreeDist package](Using-TreeDist.html), and relevant 
[principles of information theory](information.html).

## Shared phylogenetic information

Under the shared phylogenetic information tree distance measure [@SmithDist], 
pairs of splits are assigned a similarity score that corresponds to the amount
of phylogenetic information [_sensu_ @Steel2006] that they share in common
(see [separate vignette](information.html)), a concept introduced but not 
developed by Nelson [-@Nelson1979].

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2, 
                  Plot=TreeDistPlot, matchZeros = FALSE)
SharedPhylogeneticInfo(tree1, tree2)
```

### The problem with arboreal matchings

Shared phylogenetic information is an arboreal similarity score: that is to
say, it assigns zero similarity to splits that cannot both occur on a 
single tree.  
This leads to problematic behaviour in certain cases: for example,
when the position of two distant taxa is swapped, similarities within a tree can
be obscured.  
The two trees below are identical but for the position of _A_ and
_J_, yet receive zero similarity under arboreal metrics.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(SharedPhylogeneticInfo, matchZeros = FALSE, AtoJ, AotJ,
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
```

## Mutual clustering information

Scoring each pair of splits according to their mutual clustering information
[@SmithDist]  (see [separate vignette](information.html)) results in a
non-arboreal information-based tree distance metric that, as desired, assigns a
non-zero similarity to the case that received zero similarity under an
arboreal matching:

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, AtoJ, AotJ, matchZeros = FALSE, 
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
MutualClusteringInfo(AtoJ, AotJ)
```

Because no pair of non-trivial splits has zero mutual clustering information,
even a dissimilar matching (such as `HI|ABCDEFG` => `EI|ABCDFGH` below) 
is preferred to leaving a split unpaired.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

## Nye _et al._ tree similarity metric

The Nye _et al_. [-@Nye2006] tree similarity metric scores pairs by
considering the elements held in common between subsets of each split.

Consider a pair of splits `ABCDEF|GHIJ` and `ABCDEIJ|FGH`.
These can be aligned thus:

```
ABCDEF  | GHIJ
ABCDE IJ|FGH
```

The first pair of subsets, `ABCDEF` and `ABCDEIJ`, have five elements in common 
(`ABCDE`), and together encompass eight elements (`ABCDEFIJ`).  Their 
_subset score_ is thus 5/8.

The second pair of subsets, `GHIJ` and `FGH`, have two elements (`GH`) in common,
of the five total (`FGHIJ`), and hence receive a subset score of 2/5.

This split alignment then receives an _alignment score_ corresponding to the 
lower of the two subset scores, 2/5.

We must now consider the other alignment of this pair of splits,


```
ABCDEF  |     GHIJ
     FGH|ABCDE  IJ
```

This yields subset scores of 1/8 and 2/9, and thus has an alignment score of 1/8.
This alignment gives a lower score than the other, so is disregarded.  The 
pair of splits is allocated a similarity score corresponding to the 
better alignment: 2/5.

As such, splits that match exactly will receive a similarity score of 1,
in a manner analogous to the Robinson-Foulds distance.  (This is despite the
fact that some splits are more likely to match than others.)
It is not possible for a pair of splits to receive a zero similarity 
score.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(NyeTreeSimilarity, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
NyeTreeSimilarity(tree1, tree2, normalize=FALSE)
```

### Jaccard-Robinson-Foulds metric

B&ouml;cker _et al_. [-@Bocker2013] propose expressly prohibiting contradictory
pairings, i.e. pairs of splits that could never occur in the same tree.
Such an 'arboreal' matching would preclude the pairing of `ABCFGHI|DE` with
`ABCDFGH|EI`:

```{r, fig.width=6 , fig.align='center'}
JaccardRobinsonFoulds(tree1, tree2, similarity = TRUE)

VisualizeMatching(JaccardRobinsonFoulds, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

B&ouml;cker _et al_. [-@Bocker2013] also suggest raising the split 
similarity score defined above to an arbitrary exponent.  The similarity score
is also doubled.  By this means, the metric can be made to converge to the
Robinson-Foulds metric as the exponent grows towards infinity.

```{r, fig.width=6, fig.height = 4,fig.align='center', echo=FALSE}
par(mar=c(4, 4, 0, 0))
x <- seq(1, 20, by=0.1)
cbPalette8 <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
                "#0072B2", "#D55E00", "#CC79A7") # dput(Ternary::cbPalette8)
plot(0, xlim = range(x), ylim = c(3.5, 9.5),
     xlab = expression(italic('k')), ylab = 'Jaccard-Robinson-Foulds distance',
     pch = 3, type='n')

abline(h = RobinsonFoulds(tree1, tree2),
       lty = 'dashed', col = cbPalette8[6])
abline(h = NyeTreeSimilarity(tree1, tree2, similarity = FALSE),
       lty = 'dotted', col = cbPalette8[8])

lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1 = tree1, tree2 = tree2,
                        arboreal = FALSE, 0), col = cbPalette8[5])
lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1 = tree1, tree2 = tree2,
                        0), col = cbPalette8[4])

legend('right', c('Robinson-Foulds', 'Arboreal', 'Non-arboreal', 'Nye et al.'),
       lty = c('dashed', 'solid', 'solid', 'dotted'), 
       col = cbPalette8[c(6, 4, 5, 8)], bty = 'n')
```

## Matching Split Distance

Bogdanowicz & Giaro [-@Bogdanowicz2012] propose an alternative distance, which
they term the Matching Split Distance.  (This was independently proposed by
Lin _et al._ [-@Lin2012].)

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(tree1, tree2)
VisualizeMatching(MatchingSplitDistance, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

Note that the visualization shows the difference, rather than the similarity,
between splits.

Similar to the Nye _et al_. similarity metric, this method compares the subsets
implied by a pair of splits.  Here, the relevant quantity is the number
of elements that must be moved from one subset to another in order to make
the two splits identical.  With the pair of splits

```
ABCDEF  | GHIJ
ABCDE IJ|FGH
```

three leaves (_F_, _I_ and _J_) must be moved before the splits are 
identical; as such, the pair of splits are assigned a difference score 
of three.  
Formally, where $S_i$ splits $n$ leaves into bipartitions $A_i$ and $B_i$, the
difference score is calculated by

$n - m$

where $m$ counts the number of leaves that already match, and is defined as

$m = \max\{|A_1 \cap A_2| + |B_1 \cap B_2|, |A_1 \cap B_2| + |B_1 \cap A_2|\}$

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(read.tree(text='((a, b, c, d, e, f), (g, h, i, j));'),
                      read.tree(text='((a, b, c, d, e, i, j), (g, h, f));'))
```

This distance is difficult to normalize, as its maximum value is difficult
to calculate.

### Information theoretic alternative

In the matching split distance, $m$ represents a simple count of the number of
shared taxa.  An alternative is to measure the phylogenetic information content
of the largest split consistent with $S_1$ and $S_2$:

$m = \max\{h(A_1 \cap A_2 | B_1 \cap B_2), h(A_1 \cap B_2 | B_1 \cap A_2)\}$

The most information-rich split consistent with

```
ABCDEF  | GHIJ
ABCDE IJ|FGH  
```

is `ABCDE | GH`, which contains 
```{r}
TreeTools::SplitInformation(5, 2)
```
bits of phylogenetic information, which provides a similarity score for this
pairing.

```{r, fig.width=6 , fig.align='center'}
MatchingSplitInfoDistance(tree1, tree2)
VisualizeMatching(MatchingSplitInfoDistance, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```


## References
