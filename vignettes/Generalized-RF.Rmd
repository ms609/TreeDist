---
title: "Generalized Robinson-Foulds distances"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Generalized Robinson-Foulds distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, message=FALSE, warning=FALSE, echo = FALSE}
library('ape')
library('TreeDist')
tree1 <- read.tree(text='((A, B), ((C, (D, E)), (F, (G, (H, I)))));')
tree2 <- read.tree(text='((A, B), ((C, D, (E, I)), (F, (G, H))));')
AtoJ <-  read.tree(text='(((((A, B), C), D), E), (F, (G, (H, (I, J)))));')
AotJ <-  read.tree(text='(((((J, B), C), D), E), (F, (G, (H, (I, A)))));')
```

This document outlines the similarity measures employed by the 
generalized Robinson-Foulds distances implemented in this package.

Before you read it, you may wish to refresh your memory of the 
[Robinson-Foulds distance](Robinson-Foulds.html), or how to
[use the TreeDist package](Using-TreeDist.html).  To understand the
information-based metrics, it is useful to be familiar with 
[concepts of information](information.html).

## Mutual phylogenetic information

Under the mutual phylognetic information tree distance measure [@SmithDist], 
pairs of partitions are assigned a similarity score that corresponds to their
mutual phylogenetic information content.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualPhylogeneticInfo, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
MutualPhylogeneticInfo(tree1, tree2)
```

The phylogenetic information content of a partition is defined as
the negative logarithm of the proportion of all bifurcating _n_-tip trees that
contain that partition.  Thus a more even bipartition, which is consistent with
a smaller proportion of trees, contains more phylogenetic information.

The mutual phylogenetic information of two partitions is the information that
they contain in common; that is, the sum of the information content of the two 
splits, minus the joint information (which is the negative logarithm of the 
proportion of trees that contain both partitions).

Consider the splits `ABCDEF:GHI` and `ABCDEFI:GH`.  

```{r}
library('TreeSearch')
treesMatchingSplit <- c(
  ABCDEF.GHI = TreesMatchingSplit(6, 3),
  ABCDEFI.GH = TreesMatchingSplit(7, 2)
)
treesMatchingSplit

proportionMatchingSplit <- treesMatchingSplit / NUnrooted(9)
proportionMatchingSplit

splitInformation <- -log2(proportionMatchingSplit)
splitInformation

treesMatchingBoth <- TreesConsistentWithTwoSplits(9, 6, 7)
jointInformation <- -log2(treesMatchingBoth / NUnrooted(9))

mutualInformation <- sum(splitInformation) - jointInformation
mutualInformation

# Or more concisely:
SplitMutualInformation(n = 9, 6, 7)
```


<!--#TODO: 1 != 1; need to normalize.-->

### The problem with arboreal matchings

The mutual phylogenetic information is an arboreal similarity score: that is to
say, it assigns zero similarity to partitions that cannot both occur on a 
single tree.  
This leads to problematic behaviour in certain cases: for example,
when the position of two distant taxa is swapped, similarities within a tree can
be obscured.  
The two trees below are identical but for the position of _A_ and
_J_, yet receive zero similarity under arboreal metrics.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualPhylogeneticInfo, matchZeros = FALSE, AtoJ, AotJ,
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
```

## Mutual clustering information

Clustering information [@SmithDist] provides a non-arboreal information-based
tree distance metric.
As desired, this assigns a non-zero similarity to the case that received zero
similarity under an arboreal matching:

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, AtoJ, AotJ, matchZeros = FALSE, 
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
MutualClusteringInfo(AtoJ, AotJ)
```

Here, each partition is viewed as clustering the terminals into two groups.
Consider a pair of partitions, Y~1~ and Y~2~. 
If the partitions are identical, then if an observer knows which group a
terminal is in Y~1~, then this gives all the information they need to know
which group it is in in Y~2~.  As the partitions become more different, the
disposition of Y~1~ gives less information about the configuration of Y~2~;
the probability that a guess based on Y~1~ will be correct decreases, and 
the mutual information decreases accordingly.

The mutual clustering information has the notable property that no pair
of splits will be allocated zero similarity.  As such, even a dissimilar 
matching (such as `HI:ABCDEFG` => `EI:ABCDFGH` below) 
is preferred to leaving a partition unpaired.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

## Nye _et al._ tree similarity metric

The Nye _et al_. [-@Nye2006] tree similarity metric scores pairs by
considering the elements held in common between subsets of each partition.

Consider a pair of partitions `ABCDEF:GHIJ` and `ABCDEIJ:FGH`.
These can be aligned thus:

`ABCDEF  : GHIJ`
`ABCDE IJ:FGH  `

The first pair of subsets, `ABCDEF` and `ABCDEIJ`, have five elements in common 
(`ABCDE`), and together encompass eight elements (`ABCDEFIJ`).  Their 
_subset score_ is thus 5/8.

The second pair of subsets, `GHIJ` and `FGH`, have two elements (`GH`) in common,
of the five total (`FGHIJ`), and hence receive a subset score of 2/5.

This split alignment then receives an _alignment score_ corresponding to the 
lower of the two subset scores, 2/5.

We must now consider the other alignment of this pair of partitions,


`ABCDEF  :     GHIJ`
`     FGH:ABCDE  IJ`

This yields subset scores of 1/8 and 2/9, and thus has an alignment score of 1/8.
This alignment gives a lower score than the other, so is disregarded.  The 
pair of partitions is allocated a similarity score corresponding to the 
better alignment: 2/5.

As such, partitions that match exactly will receive a similarty score of 1,
in a manner analagous to the Robinson-Foulds distance.  (This is despite the
fact that some partitions are more likely to match than others.)
And it is not possible for a pair of partitions to receive a zero similarity 
score.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(NyeTreeSimilarity, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
NyeTreeSimilarity(tree1, tree2, normalize=FALSE)
```

### Jaccard-Robinson-Foulds metric

B&ouml;cker _et al_. [-@Bocker2013] propose expressly prohibiting contradictory
pairings, i.e. pairs of partitions that could never occur in the same tree.
Such an 'arboreal' matching would preclude the pairing of `ABCFGHI:DE` with
`ABCDFGH:EI`:

```{r, fig.width=6 , fig.align='center'}
JaccardRobinsonFoulds(tree1, tree2, similarity = TRUE)

VisualizeMatching(JaccardRobinsonFoulds, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

B&ouml;cker _et al_. [-@Bocker2013] also suggest raising the partition 
similarity score defined above to an arbitrary exponent.  The similarity score
is also doubled.  By this means, the metric can be made to converge to the
Robinson-Foulds metric as the exponent grows towards infinity.

```{r, fig.width=6, fig.height = 4,fig.align='center', echo=FALSE}
par(mar=c(4, 4, 0, 0))
x <- seq(1, 20, by=0.1)
cbPalette8 <- Ternary::cbPalette8
plot(0, xlim=range(x), ylim=c(3.5, 9.5),
     xlab = 'k', ylab = 'Jaccard-Robinson-Foulds distance', pch = 3, type='n')

abline(h = RobinsonFoulds(tree1, tree2),
       lty = 'dashed', col=cbPalette8[6])
abline(h = NyeTreeSimilarity(tree1, tree2, similarity = FALSE),
       lty = 'dotted', col=cbPalette8[8])

lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1=tree1, tree2=tree2, 
                        arboreal=FALSE, 0), col=cbPalette8[5])
lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1=tree1, tree2=tree2, 0),
      col=cbPalette8[4])

legend('right', c('Robinson-Foulds', 'Arboreal', 'Non-arboreal', 'Nye et al.'),
       lty = c('dashed', 'solid', 'solid', 'dotted'), 
       col = cbPalette8[c(6, 4, 5, 8)], bty = 'n')
```

## Matching Split Distance

Bogdanowicz & Giaro [-@Bogdanowicz2012] propose an alternative distance, which
they term the Matching Split Distance.

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(tree1, tree2)
VisualizeMatching(MatchingSplitDistance, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

Note that the visualization shows the difference, rather than the similarity,
between splits.

Similar to the Nye _et al_. similarity metric, this method compares the subsets
implied by a pair of partitions.  Here, the relevanat quantity is the number
of elements that must be moved from one subset to another in order to make
the two partitions identical.  With the pair of partitions

`ABCDEF  : GHIJ`
`ABCDE IJ:FGH  `

three elements (_F_, _I_ and _J_) must be moved before the partitions are 
identical; as such, the pair of partitions are assigned a difference score 
(not a similarity score) of three.

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(read.tree(text='((a, b, c, d, e, f), (g, h, i, j));'),
                      read.tree(text='((a, b, c, d, e, i, j), (g, h, f));'))
```

This distance is difficult to normalize, as its maximum value is difficult
to calculate.

### Information theoretic alternative

An information-theoretic take on the Matching Split Distance [@SmithDist] 
is provided by the function

```{r, fig.width=6 , fig.align='center'}
VariationOfMatchingSplitInfo(tree1, tree2)
VisualizeMatching(VariationOfMatchingSplitInfo, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

This approach scores each pair of bipartitions according to the information 
content of the most information-rich bipartition that is consistent with both
partitions in the pair. 

The most information-rich bipartition consistent with 

`ABCDEF  : GHIJ`
`ABCDE IJ:FGH  `

is `ABCDE : GH`, which contains 
```{r}
SplitInformation(5, 2)
```
bits of information; this quantity represents the _similarity_ score for this
particular pairing.

This measure can therefore be normalized against the phylogenetic information
content of the two input trees.

## References