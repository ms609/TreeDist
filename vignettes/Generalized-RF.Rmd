---
title: "Generalized Robinson-Foulds distances"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Generalized Robinson-Foulds distances}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r init, message=FALSE, warning=FALSE, echo = FALSE}
library('ape')
library('TreeDist')
tree1 <- read.tree(text='((A, B), ((C, (D, E)), (F, (G, (H, I)))));')
tree2 <- read.tree(text='((A, B), ((C, D, (E, I)), (F, (G, H))));')
AtoJ <-  read.tree(text='(((((A, B), C), D), E), (F, (G, (H, (I, J)))));')
AotJ <-  read.tree(text='(((((J, B), C), D), E), (F, (G, (H, (I, A)))));')
```

This document outlines the similarity measures employed by the 
generalized Robinson-Foulds distances implemented in this package.

Before you read it, you may wish to refresh your memory of the 
[Robinson-Foulds distance](Robinson-Foulds.html), how to
[use the TreeDist package](Using-TreeDist.html), and relevant 
[principles of information theory](information.html).

## Shared phylogenetic information

Under the shared phylogenetic information tree distance measure [@SmithDist], 
pairs of splits are assigned a similarity score that corresponds to the amount
of phylogenetic information [_sensu_ @Steel2006] that they share in common
(see [separate vignette](information.html)).

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualPhylogeneticInfo, tree1, tree2, 
                  Plot=TreeDistPlot, matchZeros = FALSE)
MutualPhylogeneticInfo(tree1, tree2)
```

### The problem with arboreal matchings

The mutual phylogenetic information is an arboreal similarity score: that is to
say, it assigns zero similarity to partitions that cannot both occur on a 
single tree.  
This leads to problematic behaviour in certain cases: for example,
when the position of two distant taxa is swapped, similarities within a tree can
be obscured.  
The two trees below are identical but for the position of _A_ and
_J_, yet receive zero similarity under arboreal metrics.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualPhylogeneticInfo, matchZeros = FALSE, AtoJ, AotJ,
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
```

## Mutual clustering information

Scoring each pair of splits according to their mutual clustering information
[@SmithDist]  (see [separate vignette](information.html)) results in a
non-arboreal information-based tree distance metric that, as desired, assigns a
non-zero similarity to the case that received zero similarity under an
arboreal matching:

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, AtoJ, AotJ, matchZeros = FALSE, 
                  Plot=TreeDistPlot, leaveRoom = FALSE, prune=c(5, 18))
MutualClusteringInfo(AtoJ, AotJ)
```

Because no pair of non-trivial splits has zero mutual clustering information,
even a dissimilar matching (such as `HI|ABCDEFG` => `EI|ABCDFGH` below) 
is preferred to leaving a partition unpaired.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(MutualClusteringInfo, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

## Nye _et al._ tree similarity metric

The Nye _et al_. [-@Nye2006] tree similarity metric scores pairs by
considering the elements held in common between subsets of each partition.

Consider a pair of partitions `ABCDEF|GHIJ` and `ABCDEIJ|FGH`.
These can be aligned thus:

`ABCDEF  | GHIJ`
`ABCDE IJ|FGH  `

The first pair of subsets, `ABCDEF` and `ABCDEIJ`, have five elements in common 
(`ABCDE`), and together encompass eight elements (`ABCDEFIJ`).  Their 
_subset score_ is thus 5/8.

The second pair of subsets, `GHIJ` and `FGH`, have two elements (`GH`) in common,
of the five total (`FGHIJ`), and hence receive a subset score of 2/5.

This split alignment then receives an _alignment score_ corresponding to the 
lower of the two subset scores, 2/5.

We must now consider the other alignment of this pair of partitions,


`ABCDEF  |     GHIJ`
`     FGH|ABCDE  IJ`

This yields subset scores of 1/8 and 2/9, and thus has an alignment score of 1/8.
This alignment gives a lower score than the other, so is disregarded.  The 
pair of partitions is allocated a similarity score corresponding to the 
better alignment: 2/5.

As such, partitions that match exactly will receive a similarity score of 1,
in a manner analogous to the Robinson-Foulds distance.  (This is despite the
fact that some partitions are more likely to match than others.)
And it is not possible for a pair of partitions to receive a zero similarity 
score.

```{r, fig.width=6 , fig.align='center'}
VisualizeMatching(NyeTreeSimilarity, tree1, tree2, 
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
NyeTreeSimilarity(tree1, tree2, normalize=FALSE)
```

### Jaccard-Robinson-Foulds metric

B&ouml;cker _et al_. [-@Bocker2013] propose expressly prohibiting contradictory
pairings, i.e. pairs of partitions that could never occur in the same tree.
Such an 'arboreal' matching would preclude the pairing of `ABCFGHI|DE` with
`ABCDFGH|EI`:

```{r, fig.width=6 , fig.align='center'}
JaccardRobinsonFoulds(tree1, tree2, similarity = TRUE)

VisualizeMatching(JaccardRobinsonFoulds, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

B&ouml;cker _et al_. [-@Bocker2013] also suggest raising the partition 
similarity score defined above to an arbitrary exponent.  The similarity score
is also doubled.  By this means, the metric can be made to converge to the
Robinson-Foulds metric as the exponent grows towards infinity.

```{r, fig.width=6, fig.height = 4,fig.align='center', echo=FALSE}
par(mar=c(4, 4, 0, 0))
x <- seq(1, 20, by=0.1)
cbPalette8 <- Ternary::cbPalette8
plot(0, xlim=range(x), ylim=c(3.5, 9.5),
     xlab = 'k', ylab = 'Jaccard-Robinson-Foulds distance', pch = 3, type='n')

abline(h = RobinsonFoulds(tree1, tree2),
       lty = 'dashed', col=cbPalette8[6])
abline(h = NyeTreeSimilarity(tree1, tree2, similarity = FALSE),
       lty = 'dotted', col=cbPalette8[8])

lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1=tree1, tree2=tree2, 
                        arboreal=FALSE, 0), col=cbPalette8[5])
lines(x = x, y = vapply(x, JaccardRobinsonFoulds, tree1=tree1, tree2=tree2, 0),
      col=cbPalette8[4])

legend('right', c('Robinson-Foulds', 'Arboreal', 'Non-arboreal', 'Nye et al.'),
       lty = c('dashed', 'solid', 'solid', 'dotted'), 
       col = cbPalette8[c(6, 4, 5, 8)], bty = 'n')
```

## Matching Split Distance

Bogdanowicz & Giaro [-@Bogdanowicz2012] propose an alternative distance, which
they term the Matching Split Distance.

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(tree1, tree2)
VisualizeMatching(MatchingSplitDistance, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

Note that the visualization shows the difference, rather than the similarity,
between splits.

Similar to the Nye _et al_. similarity metric, this method compares the subsets
implied by a pair of partitions.  Here, the relevant quantity is the number
of elements that must be moved from one subset to another in order to make
the two partitions identical.  With the pair of partitions

`ABCDEF  | GHIJ`
`ABCDE IJ|FGH  `

three elements (_F_, _I_ and _J_) must be moved before the partitions are 
identical; as such, the pair of partitions are assigned a difference score 
(not a similarity score) of three.

```{r, fig.width=6 , fig.align='center'}
MatchingSplitDistance(read.tree(text='((a, b, c, d, e, f), (g, h, i, j));'),
                      read.tree(text='((a, b, c, d, e, i, j), (g, h, f));'))
```

This distance is difficult to normalize, as its maximum value is difficult
to calculate.

### Information theoretic alternative

An information-theoretic take on the Matching Split Distance [@SmithDist] 
is provided by the function

```{r, fig.width=6 , fig.align='center'}
VariationOfMatchingSplitInfo(tree1, tree2)
VisualizeMatching(VariationOfMatchingSplitInfo, tree1, tree2,
                  Plot=TreeDistPlot, leaveRoom=FALSE, matchZeros = FALSE)
```

This approach scores each pair of bipartitions according to the information 
content of the most information-rich bipartition that is consistent with both
partitions in the pair.

The most information-rich bipartition consistent with 

`ABCDEF  | GHIJ`
`ABCDE IJ|FGH  `

is `ABCDE | GH`, which contains 
```{r}
TreeTools::SplitInformation(5, 2)
```
bits of phylogenetic information; this quantity represents the similarity (not
difference) score for this particular pairing.

This measure can therefore be normalized against the phylogenetic information
content of the two input trees.

## References
