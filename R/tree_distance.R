#' Information-based generalized Robinson-Foulds distances
#'
#' Tree similarity and distance measures that measure the amount of 
#' phylogenetic or clustering information that two trees hold in common.
#' 
#' 
#' A tree similarity measure is generated by finding an optimal matching that
#' maximises the total information in common between a partition on one tree
#' and its pair on a second, considering all possible ways to pair partitions 
#' between trees (including leaving a partition unpaired).
#' 
#' The returned tree similarity measures state the amount of information, 
#' in bits, that the partitions in two trees hold in common 
#' when they are optimally matched, following Smith (forthcoming).  
#' The complementary tree distance measures state how much information is 
#' different in the partitions of two trees, under an optimal matching.
#' 
#' @section Concepts of information:
#'
#' Each partition in a tree can be viewed as a statement that the 'true' 
#' tree is one of those that splits the taxa as specified.  This concept
#' corresponds to the concept of phylogenetic information, which views the
#' information content of a pair of partitions as relating to the proportion of
#' phylogenetic trees that are consistent with both partitions.
#' 
#' This proportion gives rise to the Mutual Phylogenetic Information similarity 
#' measure (`MutualPhylogeneticInfo`), and the complementary 
#' Variation of Phylogenetic Information distance metric
#' (`VariationOfPhylogeneticInfo`).
#' 
#' An information-theoretic take on the [`MatchingSplitDistance`] offers a 
#' relaxed interpretation of this measurement, which attributes some information
#' to similar yet contradictory splits.  This metric is implemented in
#' `MutualMatchingSplitInfo` and `VariationOfMatchingSplitInfo`.
#' 
#' Alternatively, each partition can be viewed as a statement that the taxa
#' are subdivided into the two groups specified.  On this view, the 
#' information content of a pair of partitions corresponds to their
#' mutual clustering information (Meila 2007, Vinh2010), giving rise to their
#' Mutucal Clustering Information and Variation of Clustering Information
#' similarity/distance metrics (`MutualClusteringInfo`, `VariationOfClusteringInfo`).
#' 
#' This latter approach is optimal in many regards, and is implemented, normalized
#' against the total information present, in the convenience function `TreeDistance`.
#' 
#' 
#' @section Normalization:
#' 
#' If `normalize = TRUE`, then results will be rescaled from zero to a nominal
#' maximum value, calculated thus:
#' 
#' * `MutualPhylogeneticInfo`, `MutualClusteringInfo`, `MutualMatchingSplitInfo`:
#'  The information content of the least informative tree.
#'  To scale against the information content of the most informative tree, use
#' `normalize = pmax`.
#' 
#' * `VariationOfPhylogeneticInfo`, `VariationOfClusteringInfo`,
#' `VariationOfMatchingSplitInfo`: The sum of the
#' (phylogenetic or clustering) information content of the two trees.
#' 
#' @template tree12Params
#' 
#' @param normalize If a numeric value is provided, this will be used as a 
#' maximum value against which to rescale results.
#' If `TRUE`, results will be rescaled against a maximum value calculated from
#' the specified tree sizes and topology, as specified in the 'Normalization' 
#' section below.
#' If `FALSE`, results will not be rescaled.
#' 
#' @param reportMatching Logical specifying whether to return the clade
#' matchings as an attribute of the score.
#'
#' @return If `reportMatching = FALSE`, the functions return a numeric 
#' vector specifying the requested similarities or differences.
#' 
#' If `reportMatching = TRUE`, the functions additionally return details
#' of which clades are matched in the optimal matching, which can be viewed
#' using [`VisualizeMatching`].
#'  
#' @examples {
#'   tree1 <- ape::read.tree(text='((((a, b), c), d), (e, (f, (g, h))));')
#'   tree2 <- ape::read.tree(text='(((a, b), (c, d)), ((e, f), (g, h)));')
#'   tree3 <- ape::read.tree(text='((((h, b), c), d), (e, (f, (g, a))));')
#'   
#'   # Best possible score is obtained by matching a tree with itself
#'   VariationOfPhylogeneticInfo(tree1, tree1) # 0, by definition
#'   MutualPhylogeneticInfo(tree1, tree1)
#'   PartitionInfo(tree1) # Maximum mutual phylogenetic information
#'   
#'   # Best possible score is a function of tree shape; the partitions within
#'   # balanced trees are more independent and thus contain less information
#'   PartitionInfo(tree2)
#'   
#'   # How similar are two trees?
#'   MutualPhylogeneticInfo(tree1, tree2) # Amount of phylogenetic information in common
#'   VisualizeMatching(MutualPhylogeneticInfo, tree1, tree2) # Which clades are matched?
#'   VariationOfPhylogeneticInfo(tree1, tree2) # Distance measure
#'   VariationOfPhylogeneticInfo(tree2, tree1) # The metric is symmetric
#'   #'   
#'   # Are they more similar than two trees of this shape would be by chance?
#'   ExpectedVariation(tree1, tree2, sample=12)['VariationOfPhylogeneticInfo', 'Estimate']
#'   
#'   # Every partition in tree1 is contradicted by every partition in tree3
#'   # Non-arboreal matches contain clustering, but not phylogenetic, information
#'   MutualPhylogeneticInfo(tree1, tree3) # = 0
#'   MutualClusteringInfo(tree1, tree3) # > 0
#'   
#' }
#' 
#' 
#' @references {
#'  * \insertRef{Meila2007}{TreeDist}
#'  * \insertRef{SmithDist}{TreeDist}
#'  * \insertRef{Vinh2010}{TreeDist}
#' }
#' 
#' @author Martin R. Smith
#' 
#' @family tree distances
#' @importFrom clue solve_LSAP
#' @export
TreeDistance <- function (tree1, tree2) {
  MutualClusteringInfo(tree1, tree2, normalize = TRUE, reportMatching = FALSE)
}

#' @describeIn TreeDistance Mutual phylogenetic information between two trees.
#' @export
MutualPhylogeneticInfo <- function (tree1, tree2, normalize = FALSE,
                                reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MutualPhylogeneticInfoSplits, tree1, tree2, 
                                        reportMatching=reportMatching)
  
  # Return:
  NormalizeInfo(unnormalized, tree1, tree2, how = normalize,
                InfoInTree = PartitionInfo, Combine = pmin)
}

#' @describeIn TreeDistance Variation of phylogenetic information between two trees.
#' @export
VariationOfPhylogeneticInfo <- function (tree1, tree2, normalize = FALSE,
                                     reportMatching = FALSE) {
  mai <- MutualPhylogeneticInfo(tree1, tree2, normalize = FALSE,
                            reportMatching = reportMatching)
  treesIndependentInfo <- outer(PartitionInfo(tree1), PartitionInfo(tree2), '+')
  
  ret <- treesIndependentInfo - mai - mai
  ret <- NormalizeInfo(ret, tree1, tree2, how=normalize, 
                       infoInBoth = treesIndependentInfo,
                       InfoInTree = PartitionInfo, Combine = '+')
  
  ret[ret < 1e-13] <- 0 # In case of floating point inaccuracy
  attributes(ret) <- attributes(mai)
  
  # Return:
  ret
}

#' @describeIn TreeDistance Variation of clustering information between two trees.
#' @export
VariationOfClusteringInfo <- function (tree1, tree2, normalize = FALSE,
                                       reportMatching = FALSE) {
  mci <- MutualClusteringInfo(tree1, tree2, normalize = FALSE, 
                              reportMatching = reportMatching)
  treesIndependentInfo <- outer(ClusteringInfo(tree1), ClusteringInfo(tree2), '+')
  
  ret <- treesIndependentInfo - mci - mci
  ret <- NormalizeInfo(ret, tree1, tree2, how = normalize,
                       infoInBoth = treesIndependentInfo,
                       InfoInTree = ClusteringInfo, Combine = '+')
  
  ret[ret < 1e-13] <- 0 # In case of floating point inaccuracy
  attributes(ret) <- attributes(mci)
  
  # Return:
  ret
}



#' @describeIn TreeDistance Estimate expected Variation of 
#' Phylogenetic Information and Mutual Phylogenetic Information for a pair of trees of
#' a given topology.
#' @param samples Integer specifying how many samplings to obtain; 
#' accuracy of estimate increases with `sqrt(samples)`.
#' @importFrom stats sd
#' @importFrom TreeSearch Tree2Splits
#' @export
ExpectedVariation <- function (tree1, tree2, samples = 1e+3) {
  info1 <- PartitionInfo(tree1)
  info2 <- PartitionInfo(tree2)
  splits1 <- Tree2Splits(tree1)
  splits2 <- Tree2Splits(tree2)
  tipLabels <- rownames(splits2)
  
  mutualEstimates <- vapply(seq_len(samples), function (x) {
    rownames(splits2) <- sample(tipLabels)
    c(MutualPhylogeneticInfoSplits(splits1, splits2),
      MutualMatchingSplitInfoSplits(splits1, splits2))
  }, c(MutualPhylogeneticInfo = 0, MutualMatchingSplitInfo = 0))
  
  mut <- cbind(Estimate = rowMeans(mutualEstimates),
               sd = apply(mutualEstimates, 1, sd), n = samples)
  
  ret <- rbind(mut,
               VariationOfPhylogeneticInfo = c(info1 + info2 - mut[1, 1] - mut[1, 1], mut[1, 2] * 2, samples),
               VariationOfMatchingSplitInfo =  c(info1 + info2 - mut[2, 1] - mut[2, 1], mut[2, 2] * 2, samples)
               )
  
  # Return:
  cbind(Estimate = ret[, 1], 'Std. Err.' = ret[, 'sd'] / sqrt(ret[, 'n']), ret[, 2:3])
}

#' @describeIn TreeDistance Mutual Clustering Information of two trees.
#' @export
MutualClusteringInfo <- function (tree1, tree2, normalize = FALSE,
                                  reportMatching = FALSE) {
  unnormalized <- CalculateTreeDistance(MutualClusteringInfoSplits, tree1, tree2,
                                        reportMatching)
  NormalizeInfo(unnormalized, tree1, tree2, ClusteringInfo, 
                how = normalize, Combine = pmin)
}

#' @describeIn TreeDistance Calculate mutual phylogenetic information from splits instead of trees.
#' @template splits12params
#' @export
MutualPhylogeneticInfoSplits <- function (splits1, splits2, reportMatching = FALSE) {
  GeneralizedRF(splits1, splits2, 
                function(splits1, splits2, nSplits1, nSplits2) {
    nTerminals <- dim(splits1)[1]
    lnUnrootedN <- LnUnrooted.int(nTerminals)
    inSplit1 <- colSums(splits1)
    inSplit2 <- colSums(splits2)
    notInSplit2 <- nTerminals - inSplit2
    
    if (nTerminals <= length(oneOverlap)) {
      # Use cache for speed, if available
      oo <- oneOverlap[[nTerminals]]
      OneOverlap <- function (A1, A2) oo[A1, A2]
    } else {
      OneOverlap <- function(A1, A2) {
        if (A1 == A2) {
          # Return:
          LnRooted.int(A1) + LnRooted.int(nTerminals - A2)
        } else {
          if (A1 < A2) {
            # Return:
            LnRooted.int(A2) + LnRooted.int(nTerminals - A1) - LnRooted.int(A2 - A1 + 1L) 
          } else {
            # Return:
            LnRooted.int(A1) + LnRooted.int(nTerminals - A2) - LnRooted.int(A1 - A2 + 1L) 
          }
        }
      }
    }
    
    # Return:
    matrix((mapply(function(i, j) {
      split1 <- splits1[, i]
      split2 <- splits2[, j]
      
      if (all(split1[split2]) || # oneAndTwo
          all(!split1[!split2])) { # notOneNotTwo
        OneOverlap(inSplit1[i], inSplit2[j])
        
      } else if (all(!split1[split2]) || # notOneAndTwo
                 all(split1[!split2])) { #oneNotTwo
        OneOverlap(inSplit1[i], notInSplit2[j])
        
      } else {
        lnUnrootedN
      }
    }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
    ) - lnUnrootedN) / -log(2), nSplits1, nSplits2)
  }, maximize = TRUE, reportMatching)
}

#' @describeIn TreeDistance Calculate clustering information from splits instead of trees
#' @export
MutualClusteringInfoSplits <- function (splits1, splits2, 
                                        reportMatching = FALSE) {
  GeneralizedRF(splits1, splits2, 
                function(splits1, splits2, nSplits1, nSplits2) {
    matrix((mapply(function(i, j) {
      MeilaMutualInformation(splits1[, i], splits2[, j])
    }, seq_len(nSplits1), rep(seq_len(nSplits2), each=nSplits1)
    )), nSplits1, nSplits2) / log(2)
  }, maximize = TRUE, reportMatching)
}

#' Generalized Robinson-Foulds distance
#' 
#' Calculate Generalized Robinson-Foulds distance from splits.
#' 
#' @inheritParams MutualPhylogeneticInfoSplits
#' @param PairScorer function taking four arguments, `splits1`, `splits2`,
#' `nSplits1`, `nSplits2`, which should return the score of each pair of splits
#' in a two-dimensional matrix.
#' 
#' @return The results of `TreeDistanceReturn` under the parameters provided
#' 
#' @keywords internal
#' @author Martin R. Smith
#' @export
GeneralizedRF <- function (splits1, splits2, PairScorer, 
                           maximize, reportMatching) {
  dimSplits1 <- dim(splits1)
  dimSplits2 <- dim(splits2)
  nSplits1 <- dimSplits1[2]
  nSplits2 <- dimSplits2[2]
  if (nSplits1 == 0 || nSplits2 == 0) return (0L)
  nTerminals <- dimSplits1[1]
  if (dimSplits2[1] != nTerminals) {
    stop("Split rows must bear identical labels")
  }
  
  taxonNames1 <- rownames(splits1)
  taxonNames2 <- rownames(splits2)
  
  if (!is.null(taxonNames2)) {
    splits2 <- unname(splits2[taxonNames1, , drop=FALSE])
    splits1 <- unname(splits1) # split2[split1] faster without names
  }
  
  pairScores <- PairScorer(splits1, splits2, nSplits1, nSplits2)
  
  # Return:
  TreeDistanceReturn(pairScores, maximize, reportMatching, 
                     splits1, splits2, taxonNames1)
}

#' Are splits compatible?
#' 
#' Splits are compatible if they are concave; i.e. they can both be true
#' simultaneously.
#' 
#' @template split12Params
#' @return `SplitsCompatible` returns a logical specifying whether the splits
#' provided are compatible with one another.
#' 
#' @author Martin R. Smith
#' @export
SplitsCompatible <- function (split1, split2) {
  # Return:
  (
    all (split1[split2]) ||
    all(split1[!split2]) ||
    all(!split1[split2]) ||
    all(!split1[!split2])
  )
}

#' Tree Distance Return
#' 
#' Generates the return value for Generalized Robinson-Foulds distances,
#' with (optionally) a report of the matching.
#' 
#' @param pairScores Two-dimensional array listing the score of each possible
#' pairing of `splits1` (rows) with `splits2` (columns).
#' @param reportMatching Logical specifying whether to report details
#' of an optimal matching.
#' @template splits12params
#' @param taxonNames Character vector listing the names corresponding to each
#' row of `splits1` and `splits2`.
#' Corresponding parameters from within each function
#' 
#' @keywords internal
#' @author Martin R. Smith
#' @export
TreeDistanceReturn <- function (pairScores, maximize = FALSE,
                                reportMatching,  
                                splits1, splits2,
                                taxonNames = NULL) {
  dimScores <- dim(pairScores)
  
  if (dimScores[1] > dimScores[2]) {
    if (dimScores[2] == 1) {
      Optimal <- if (maximize) which.max else which.min
      solution <- Optimal(pairScores)
    } else {
      solution <- solve_LSAP(t(pairScores), maximize)
    }
    optimalMatching <- structure(match(seq_len(dimScores[1]), solution),
                                 class='solve_LSAP')
  } else {
    if (dimScores[1] == 1) {
      Optimal <- if (maximize) which.max else which.min
      optimalMatching <- structure(Optimal(pairScores), class='solve_LSAP')
    } else {
      optimalMatching <- solve_LSAP(pairScores, maximize)
    }
  }
  
  
  matched <- !is.na(optimalMatching)
  matched1 <- which(matched)
  matched2 <- optimalMatching[matched]
  
  ret <- sum(pairScores[matrix(c(matched1, matched2), ncol=2L)])
  
  if (reportMatching) {
    attributes(ret) <- list(
      pairScores = pairScores,
      matching = optimalMatching
    )
    
    if (!is.null(taxonNames)) {
      attr(ret, 'matchedSplits') <- 
        ReportMatching(splits1[, matched1, drop = FALSE], 
                       splits2[, matched2, drop = FALSE],
                       taxonNames)
    }
  }
  # Return:
  ret
}