# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

COMCLUST <- function(trees) {
    .Call(`_TreeDist_COMCLUST`, trees)
}

consensus_info <- function(trees, phylo, p) {
    .Call(`_TreeDist_consensus_info`, trees, phylo, p)
}

robinson_foulds_all_pairs <- function(tables) {
    .Call(`_TreeDist_robinson_foulds_all_pairs`, tables)
}

HMI_xptr <- function(ptr1, ptr2) {
    .Call(`_TreeDist_HMI_xptr`, ptr1, ptr2)
}

HH_xptr <- function(ptr) {
    .Call(`_TreeDist_HH_xptr`, ptr)
}

#' Directly calculate entropy from an HPart pointer
#' 
#' Intended for developer use only; no safeguards against bad input.
#' May crash R if used incorrectly.
#' 
#' @param ptr,char_ptr,tree_ptr Pointers to HPart objects for which chosen
#' entropy value should be calculated.
#' @inheritParams CharAMI
#' 
#' @template MRS
#' @keywords internal
#' @export
H_xptr <- function(ptr) {
    .Call(`_TreeDist_H_xptr`, ptr)
}

#' @rdname H_xptr
#' @export
JH_xptr <- function(char_ptr, tree_ptr) {
    .Call(`_TreeDist_JH_xptr`, char_ptr, tree_ptr)
}

EHMI_xptr <- function(hp1_ptr, hp2_ptr, tolerance = 0.01, minResample = 36L) {
    .Call(`_TreeDist_EHMI_xptr`, hp1_ptr, hp2_ptr, tolerance, minResample)
}

#' @rdname H_xptr
#' @export
EJH_xptr <- function(char_ptr, tree_ptr, tolerance = 0.01, minResample = 36L) {
    .Call(`_TreeDist_EJH_xptr`, char_ptr, tree_ptr, tolerance, minResample)
}

build_hpart_from_phylo <- function(phy) {
    .Call(`_TreeDist_build_hpart_from_phylo`, phy)
}

build_hpart_from_list <- function(tree, n_tip) {
    .Call(`_TreeDist_build_hpart_from_list`, tree, n_tip)
}

hpart_to_edge <- function(hpart_xptr) {
    .Call(`_TreeDist_hpart_to_edge`, hpart_xptr)
}

clone_hpart <- function(hpart_ptr) {
    .Call(`_TreeDist_clone_hpart`, hpart_ptr)
}

relabel_hpart <- function(hpart_ptr, map) {
    invisible(.Call(`_TreeDist_relabel_hpart`, hpart_ptr, map))
}

#' Calculate entropy of integer vector of counts
#' 
#' Wrapper for C++ function; no input checking is performed.
#' [`Ntropy()`] is better suited for use where performance is not critical.
#' @param n a vector of integer counts
#' @return `entropy_int()` returns a numeric corresponding to the entropy of
#' each observation, in bits.
#' @export
#' @keywords internal
entropy_int <- function(n) {
    .Call(`_TreeDist_entropy_int`, n)
}

lapjv <- function(x, maxX) {
    .Call(`_TreeDist_lapjv`, x, maxX)
}

cpp_mast <- function(edge1, edge2, nTip) {
    .Call(`_TreeDist_cpp_mast`, edge1, edge2, nTip)
}

cpp_nni_distance <- function(edge1, edge2, nTip) {
    .Call(`_TreeDist_cpp_nni_distance`, edge1, edge2, nTip)
}

path_vector <- function(edge) {
    .Call(`_TreeDist_path_vector`, edge)
}

vec_diff_euclidean <- function(vec1, vec2) {
    .Call(`_TreeDist_vec_diff_euclidean`, vec1, vec2)
}

pair_diff_euclidean <- function(vecs) {
    .Call(`_TreeDist_pair_diff_euclidean`, vecs)
}

reduce_trees <- function(x, y, original_label) {
    .Call(`_TreeDist_reduce_trees`, x, y, original_label)
}

mismatch_size <- function(x, y) {
    .Call(`_TreeDist_mismatch_size`, x, y)
}

confusion <- function(x, y) {
    .Call(`_TreeDist_confusion`, x, y)
}

keep_and_reroot <- function(tree1, tree2, keep) {
    .Call(`_TreeDist_keep_and_reroot`, tree1, tree2, keep)
}

keep_and_reduce <- function(tree1, tree2, keep) {
    .Call(`_TreeDist_keep_and_reduce`, tree1, tree2, keep)
}

cpp_robinson_foulds_distance <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_robinson_foulds_distance`, x, y, nTip)
}

cpp_robinson_foulds_info <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_robinson_foulds_info`, x, y, nTip)
}

cpp_matching_split_distance <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_matching_split_distance`, x, y, nTip)
}

cpp_jaccard_similarity <- function(x, y, nTip, k, allowConflict) {
    .Call(`_TreeDist_cpp_jaccard_similarity`, x, y, nTip, k, allowConflict)
}

cpp_msi_distance <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_msi_distance`, x, y, nTip)
}

cpp_mutual_clustering <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_mutual_clustering`, x, y, nTip)
}

cpp_shared_phylo <- function(x, y, nTip) {
    .Call(`_TreeDist_cpp_shared_phylo`, x, y, nTip)
}

