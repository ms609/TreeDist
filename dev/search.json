[{"path":"https://ms609.github.io/TreeDist/dev/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https://www.contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"CONTRIBUTING","text":"Small typos grammatical errors documentation may edited directly using GitHub web interface, long changes made source file. : edit roxygen comment .R file R/. DON’T: edit .Rd file man/.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"prerequisites","dir":"","previous_headings":"","what":"Prerequisites","title":"CONTRIBUTING","text":"make substantial pull request, always file issue make sure someone team agrees ’s problem. ’ve found bug, create associated issue illustrate bug minimal reprex.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"","what":"Pull request process","title":"CONTRIBUTING","text":"recommend create Git branch pull request (PR). Look GitHub actions CodeCovr build status making changes. follow Google’s R style guide use camelCase variable names, TitleCase function names. use Oxford ending ‘ize’ (‘ise’), UK spelling (e.g. ‘colour’) possible avoid distinction (e.g. shortening ‘col’) use roxygen2 build documentation. use testthat. Contributions test cases included easier accept. use semantic versioning. user-facing changes, add bullet top NEWS.md current development version header describing changes made followed GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"contributor-license-agreement","dir":"","previous_headings":"","what":"Contributor license agreement","title":"CONTRIBUTING","text":"Contributors agree reassign copyright contributions maintainers package.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"CONTRIBUTING","text":"Please note project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"prefer-to-e-mail","dir":"","previous_headings":"","what":"Prefer to e-mail?","title":"CONTRIBUTING","text":"E-mail person listed maintainer DESCRIPTION file repo. Private discussions email don’t help others - course email totally warranted sensitive problems.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/CONTRIBUTING.html","id":"thanks-for-contributing","dir":"","previous_headings":"","what":"Thanks for contributing!","title":"CONTRIBUTING","text":"document adapted tidyverse contributing guide.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"shared-phylogenetic-information","dir":"Articles","previous_headings":"","what":"Shared phylogenetic information","title":"Generalized Robinson-Foulds distances","text":"shared phylogenetic information tree distance measure (Smith, 2020), pairs splits assigned similarity score corresponds amount phylogenetic information (sensu Steel & Penny, 2006) share common (see separate vignette), concept introduced (though developed) Nelson (1979).  distance measured bits; measure, total information content tree given ","code":"VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2,                    Plot = TreeDistPlot, matchZeros = FALSE) SharedPhylogeneticInfo(tree1, tree2) ## [1] 12.32188 SplitwiseInfo(tree1) ## [1] 28.67404"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"conflicting-splits-can-nevertheless-be-instructive","dir":"Articles","previous_headings":"Shared phylogenetic information","what":"Conflicting splits can nevertheless be instructive","title":"Generalized Robinson-Foulds distances","text":"Shared phylogenetic information assigns zero similarity incompatible splits, .e. occur single tree. leads problematic behaviour certain cases: example, swapping position two distant leaves (leaves ‘’ ‘J’ ) can disproportionately reduce similarity – example, zero.","code":"VisualizeMatching(SharedPhylogeneticInfo, AtoJ, swapAJ,                   Plot = TreeDistPlot, matchZeros = FALSE, prune = c(5, 18))"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"mutual-clustering-information","dir":"Articles","previous_headings":"","what":"Mutual clustering information","title":"Generalized Robinson-Foulds distances","text":"Scoring pair splits according mutual clustering information (Smith, 2020) (see separate vignette) results information-based tree distance metric recognizes similarity tree structure even every possible pairing splits conflicts:  pair non-trivial splits zero mutual clustering information, even dissimilar pairing (HI|ABCDEFG ⇒ EI|ABCDFGH ) (slightly) preferable leaving split unpaired.  total mutual clustering information single tree given ","code":"VisualizeMatching(MutualClusteringInfo, AtoJ, swapAJ,                   Plot = TreeDistPlot, matchZeros = FALSE, prune = c(5, 18)) MutualClusteringInfo(AtoJ, swapAJ) ## [1] 1.348339 VisualizeMatching(MutualClusteringInfo, tree1, tree2,                    Plot = TreeDistPlot, matchZeros = FALSE) ClusteringEntropy(tree1) ## [1] 5.120281"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"nye-et-al--tree-similarity-metric","dir":"Articles","previous_headings":"","what":"Nye et al. tree similarity metric","title":"Generalized Robinson-Foulds distances","text":"Nye et al. (2006) tree similarity metric scores pairs considering elements held common subsets split. Consider pair splits ABCDEF|GHIJ ABCDEIJ|FGH. can aligned thus: first pair subsets, ABCDEF ABCDEIJ, five elements common (ABCDE), together encompass eight elements (ABCDEFIJ). subset score thus 58\\frac{5}{8}. second pair subsets, GHIJ FGH, two elements (GH) common, five total (FGHIJ), hence receive subset score 25\\frac{2}{5}. split alignment receives alignment score corresponding lower two subset scores, 25\\frac{2}{5}. must now consider alignment pair splits, yields subset scores 18\\frac{1}{8} 29\\frac{2}{9}, thus alignment score 18\\frac{1}{8}. alignment gives lower score , disregarded. pair splits allocated similarity score corresponding better alignment: 25\\frac{2}{5}. , splits match exactly receive similarity score 1, manner analogous Robinson–Foulds distance. (despite fact splits likely match others.) possible pair splits receive zero similarity score.","code":"ABCDEF  | GHIJ ABCDE IJ|FGH ABCDEF  |     GHIJ      FGH|ABCDE  IJ VisualizeMatching(NyeSimilarity, tree1, tree2,                    Plot = TreeDistPlot, matchZeros = FALSE) NyeSimilarity(tree1, tree2, normalize = FALSE) ## [1] 3.5"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"jaccardrobinsonfoulds-metric","dir":"Articles","previous_headings":"Nye et al. tree similarity metric","what":"Jaccard–Robinson–Foulds metric","title":"Generalized Robinson-Foulds distances","text":"Böcker et al. (2013) employ split similarity calculation Nye et al. (), suggest raised arbitrary exponent order -weight contribution paired splits identical. order metric converge Robinson–Foulds metric exponent grows towards infinity, resulting score doubled.   figure shows JRF distance two trees plotted varies value exponent k, relative Nye et al. Robinson–Foulds distances trees:  theoretical practical performance JRF metric, speed calculation, best lower values k (Smith, 2020), raising question whether exponent useful. Böcker et al. (2013) suggest ‘reasonable’ matchings exhibit property term arboreality. definition arboreal matching supposes trees rooted, case split corresponds clade. arboreal matching rooted tree, pairing splits conflicts pairing splits. Consider case splits ‘’ ‘B’ tree 1 paired respectively splits ‘C’ ‘D’ tree 2. ‘’ paired ‘C’ ‘B’ ‘D’, avoid conflict: nested within B, C must nested within D B nested within , D must nested within C B overlap, C D must overlap. Equivalent statements unrooted trees little harder express. Unfortunately, constructing arboreal matchings NP-complete, making optimal arboreal matching slow find. faster alternative prohibit pairings contradictory splits, though distances generated approach theoretically less coherent practically effective calculated contradictory splits may paired, advantage approach slight increase calculation speed (Smith, 2020).","code":"JaccardRobinsonFoulds(tree1, tree2, k = 1) ## [1] 4 VisualizeMatching(JaccardRobinsonFoulds, tree1, tree2,                   Plot = TreeDistPlot, matchZeros = FALSE) JRF2 <- function(...) JaccardRobinsonFoulds(k = 2, ...) JRF2(tree1, tree2) ## [1] 5.638889 VisualizeMatching(JRF2, tree1, tree2,                   Plot = TreeDistPlot, matchZeros = FALSE)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"matching-split-distance","dir":"Articles","previous_headings":"","what":"Matching Split Distance","title":"Generalized Robinson-Foulds distances","text":"Bogdanowicz & Giaro (2012) propose alternative distance, term Matching Split Distance. (approach independently proposed Lin et al. (2012).)  Note visualization shows difference, rather similarity, splits. Similar Nye et al. similarity metric, method compares subsets implied pair splits. , relevant quantity number elements must moved one subset another order make two splits identical. pair splits three leaves (‘F’, ‘’ ‘J’) must moved splits identical; , pair splits assigned difference score three. Formally, SiS_i splits nn leaves bipartitions AiA_i BiB_i, difference score calculated n−mn - m mm counts number leaves already match, defined m=max{|A1∩A2|+|B1∩B2|,|A1∩B2|+|B1∩A2|}m = \\max\\{|A_1 \\cap A_2| + |B_1 \\cap B_2|, |A_1 \\cap B_2| + |B_1 \\cap A_2|\\} distance difficult normalize, easy calculate maximum value.","code":"MatchingSplitDistance(tree1, tree2) ## [1] 5 VisualizeMatching(MatchingSplitDistance, tree1, tree2,                   Plot = TreeDistPlot, matchZeros = FALSE) ABCDEF  | GHIJ ABCDE IJ|FGH MatchingSplitDistance(read.tree(text='((a, b, c, d, e, f), (g, h, i, j));'),                       read.tree(text='((a, b, c, d, e, i, j), (g, h, f));')) ## [1] 3"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Generalized-RF.html","id":"information-theoretic-alternative","dir":"Articles","previous_headings":"Matching Split Distance","what":"Information theoretic alternative","title":"Generalized Robinson-Foulds distances","text":"matching split distance, mm represents simple count number shared taxa. alternative measure phylogenetic information content largest split consistent S1S_1 S2S_2: m=max{h(A1∩A2|B1∩B2),h(A1∩B2|B1∩A2)}m = \\max\\{h(A_1 \\cap A_2 | B_1 \\cap B_2), h(A_1 \\cap B_2 | B_1 \\cap A_2)\\} information-rich split consistent ABCDE | GH, contains bits phylogenetic information. value can used similarity score pairing splits.","code":"ABCDEF  | GHIJ ABCDE IJ|FGH TreeTools::SplitInformation(5, 2) ## [1] 3.169925 MatchingSplitInfoDistance(tree1, tree2) ## [1] 17.27586 VisualizeMatching(MatchingSplitInfoDistance, tree1, tree2,                   Plot = TreeDistPlot, matchZeros = FALSE)"},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/articles/Robinson-Foulds.html","id":"the-robinsonfoulds-distance","dir":"Articles","previous_headings":"","what":"The Robinson–Foulds distance","title":"Extending the Robinson-Foulds metric","text":"intuitive way calculate similarity two trees calculate resolution strict consensus, corresponds number splits occur trees (Schuh & Polhemus, 1980). corresponding distance measure, Robinson–Foulds distance (Robinson & Foulds, 1981), counts number splits unique one two trees. important remember counting splits counting clades, edges nodes. tree drawn rooted (even without root edge), number splits one less number edges clades, two less number nodes. example, trees one split, two edges three nodes common.  simplicity counting splits appealing, limited underlying assumption splits equivalent. example, split separates eight leaves two sets four (right-hand tree ) 135\\frac{1}{35} chance compatible reference tree. contrast, split separates two leaves six 17\\frac{1}{7} chance matching reference tree: similarity observed five times likely arisen chance. words, failure match even split less noteworthy failure match uneven one. consequence, trees whose splits less even , average, exhibit higher Robinson–Foulds distances comparison trees. Compare balanced unbalanced eight-taxon tree:  tree divides eight taxa five splits. phylogenetic information content split function probability split match uniformly chosen random tree, .e. proportion eight-leaf binary trees contain split question. (Information content, bits, defined −log2(probability)-\\log_2(\\textrm{probability}).) , turn, function evenness split: first tree, split 1 even, dividing four taxa four others (4|4); splits 2–5 maximally uneven (2|6). split treated independent, total information content five splits 19.37 bits, whereas five splits second tree, sizes 2|6, 3|5, 4|4, 3|5 2|6, 22.54 bits. Put another way, random tree average share splits balanced tree (whose splits predominantly uneven thus likely matched) asymmetric tree (contains even splits less likely occur random tree). Indeed, 10 395 eight-leaf trees, many bear least one split common balanced tree asymmetric tree:","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/Robinson-Foulds.html","id":"information-corrected-robinsonfoulds-distance","dir":"Articles","previous_headings":"","what":"Information-corrected Robinson–Foulds distance","title":"Extending the Robinson-Foulds metric","text":"differing information content can accommodated weighting split according amount phylogenetic information contains (Smith, 2020). two tree pairs Robinson–Foulds distance two, first pair differ regard uneven split (ABCDEF|GH), obtain total difference 22.54 − (3.46 + 5.04 + 5.53 + 5.04) = 3.46 bits:  whereas second pair differ resolution even, thus information-rich, split (ABCD|EFGH), receive distance score 5.53 bits:","code":"tree1 <- ape::read.tree(text='(1, (2, (3, (4, (5, (6, (7, 8)))))));') tree2 <- ape::read.tree(text='(1, (2, (3, (4, (5, (7, (6, 8)))))));') tree3 <- ape::read.tree(text='(1, (2, (3, (5, (4, (6, (7, 8)))))));')  VisualizeMatching(InfoRobinsonFoulds, tree1, tree2,                    Plot = TreeDistPlot, prune = 12) VisualizeMatching(InfoRobinsonFoulds, tree1, tree3,                    Plot = TreeDistPlot, prune = 8)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Robinson-Foulds.html","id":"generalized-robinsonfoulds-distances","dir":"Articles","previous_headings":"","what":"Generalized Robinson–Foulds distances","title":"Extending the Robinson-Foulds metric","text":"Even accounting information content splits way, Robinson–Foulds distance readily saturated: maximum value can obtained moving single leaf.  Generalized Robinson–Foulds distances (Böcker, Canzar, & Klau, 2013; Nye, Liò, & Gilks, 2006) seek address issue. category metrics aim acknowledge semblances similar---quite-identical pairs splits, contribute zero tree similarity standard Robinson–Foulds measure. Generalized RF distances work finding matching pairs splits one tree splits . pairing scored according similarity paired splits; sum scores score matching. tree distance given score optimal matching.","code":"tree1 <- ape::read.tree(text='(1, (2, (3, (4, (5, (6, (7, 8)))))));') tree2 <- ape::read.tree(text='(8, (1, (2, (3, (4, (5, (6, 7)))))));')  VisualizeMatching(RobinsonFouldsMatching, tree1, tree2, Plot = TreeDistPlot)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Robinson-Foulds.html","id":"constructing-a-matching","dir":"Articles","previous_headings":"Generalized Robinson–Foulds distances","what":"Constructing a matching","title":"Extending the Robinson-Foulds metric","text":"Let’s consider two trees differ position one wildcard leaf, resolution clade:  trees obtain Robinson–Foulds distance nine: large distances, maximum possible trees resolution eleven. AB|CDEFGHI split common two trees:  distance score higher might expected, given much trees common; removing single leaf ‘’ results two trees differ resolution single node:  hidden similarity can better reflected similar, non-identical, splits assigned non-zero similarity scores. various ways score similarity two splits. One build idea introduced , identical splits scored according phylogenetic information content. Non-matching splits can scored according amount phylogenetic information hold common, function proportion trees consistent splits. (full explanation provided discussion Generalized Robinson–Foulds distances.)  , split AB|CDEFGHI occurs trees, , happens, makes largest contribution tree similarity score (3.70) particular pair trees. contribution made information-corrected Robinson–Foulds similarity. split ABCDEF|GHI left-hand tree paired split ABCDEFI|GH right-hand tree. ABCDEF|GHI available right-hand tree, perfect match assigned similarity SplitInformation(3, 6) = 5.57 bits. partial match instead allocated lower score 2.12 bits. Pairings incompatible splits, .e. co-exist tree, ABCDEFG|HI - ABCDFGH|EI, phylogenetic information common. (clustering information alternative way think split similarity recognizes similarity even incompatible splits.) matching depicted one many. happens optimal: optimal matching can found considering similarity score possible pairing, solving linear assignment problem find optimal set pairings. can view splits tree, named according number associated node: can see similarity scores pair splits, along optimal matching: .. denotes fifth matching contributes zero similarity score; alternative optimal matching leave splits unpaired.","code":"tree1 <- ape::read.tree(text='((A, B), ((C, (D, E)), (F, (G, (H, I)))));') tree2 <- ape::read.tree(text='((A, B), ((C, D, (E, I)), (F, (G, H))));')  Plot(tree1, tree2, highlight = 'I', prune = list(8, integer(0))) TwoTreePlot() VisualizeMatching(RobinsonFouldsMatching, tree1, tree2) TwoTreePlot() VisualizeMatching(RobinsonFouldsMatching,                   drop.tip(tree1, 'I'),                   drop.tip(tree2, 'I')) TwoTreePlot() VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2) summary(TreeTools::as.Splits(tree1, LETTERS[1:9])) ## 6 bipartition splits dividing 9 tips, A .. I ##      123456789 ##  11  **....... ##  13  ..***.... ##  14  ...**.... ##  15  .....**** ##  16  ......*** ##  17  .......** ##  ##  Tip 1: A     Tip 2: B    Tip 3: C    Tip 4: D    Tip 5: E    ##  Tip 6: F     Tip 7: G    Tip 8: H    Tip 9: I summary(TreeTools::as.Splits(tree2, LETTERS[1:9])) ## 5 bipartition splits dividing 9 tips, A .. I ##      123456789 ##  11  **....... ##  13  ..***...* ##  14  ....*...* ##  15  .....***. ##  16  ......**. ##  ##  Tip 1: A     Tip 2: B    Tip 3: C    Tip 4: D    Tip 5: E    ##  Tip 6: F     Tip 7: G    Tip 8: H    Tip 9: I attributes(SharedPhylogeneticInfo(tree1, tree2, reportMatching = TRUE)) ## $matching ## [1]  1  2 NA  4  5  3 ##  ## $matchedSplits ## [1] \"A B | C D E F G H I => A B | C D E F G H I\" ## [2] \"C D E | A B F G H I => C D E I | A B F G H\" ## [3] \"F G H I | A B C D E => F G H | A B C D E I\" ## [4] \"G H I | A B C D E F => G H | A B C D E F I\" ## [5] \"H I | A B C D E F G .. E I | A B C D F G H\" ##  ## $matchedScores ## [1] 3.700440 3.252981       NA 3.252981 2.115477 0.000000 ##  ## $pairScores ##           [,1]      [,2]      [,3]      [,4]      [,5] ## [1,] 3.7004397 0.8930848 0.2410081 0.5305147 0.2410081 ## [2,] 0.5305147 3.2529807 0.0000000 1.1825914 0.5305147 ## [3,] 0.2410081 1.3785116 0.0000000 0.5305147 0.2410081 ## [4,] 0.8930848 0.0000000 0.0000000 3.2529807 1.3785116 ## [5,] 0.5305147 0.0000000 0.0000000 0.0000000 2.1154772 ## [6,] 0.2410081 0.0000000 0.0000000 0.0000000 0.0000000"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Robinson-Foulds.html","id":"what-next","dir":"Articles","previous_headings":"Generalized Robinson–Foulds distances","what":"What next?","title":"Extending the Robinson-Foulds metric","text":"Alternatives measures split similarity, mutual clustering information, give rise Generalized Robinson–Foulds distances, can used generate meaningful tree spaces.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"loading-trees","dir":"Articles","previous_headings":"","what":"Loading trees","title":"Calculate tree similarity with 'TreeDist'","text":"Instructions loading phylogenetic trees R can found separate vignette. examples, ’ll enter two simple trees hand:","code":"tree1 <- ape::read.tree(text = '(A, ((B, (C, (D, E))), ((F, G), (H, I))));') tree2 <- ape::read.tree(text = '(A, ((B, (C, (D, (H, I)))), ((F, G), E)));')"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"calculating-distances","dir":"Articles","previous_headings":"","what":"Calculating distances","title":"Calculate tree similarity with 'TreeDist'","text":"can calculate distances pairs trees using ‘TreeDist’ package. First ’ll install package. can either install stable version CRAN repository: development version, GitHub – contain latest features may extensively tested: ’ll load package R’s working environment: Now package’s functions available within R. Let’s proceed calculate tree distances.","code":"install.packages('TreeDist') devtools::install_github('ms609/TreeDist') library('TreeDist')"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"pairs-of-trees","dir":"Articles","previous_headings":"Calculating distances","what":"Pairs of trees","title":"Calculate tree similarity with 'TreeDist'","text":"Calculating distance two trees simple : convenience function TreeDistance() returns variation clustering information two trees, normalized total information content splits.","code":"distance <- TreeDistance(tree1, tree2)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"multiple-comparisons","dir":"Articles","previous_headings":"Calculating distances","what":"Multiple comparisons","title":"Calculate tree similarity with 'TreeDist'","text":"two trees compare, can send list trees (class: list multiPhylo) distance comparison function. function calculate distance tree first list tree second.","code":"oneTree <- ape::rtree(11) twoTrees <- structure(list(one = ape::rtree(11), two = ape::rtree(11)),                       class = 'multiPhylo') threeTrees <- list(a = ape::rtree(11), b = ape::rtree(11), c = ape::rtree(11))  TreeDistance(oneTree, twoTrees) ##       one       two  ## 0.7826864 0.6856279 TreeDistance(twoTrees, threeTrees) ##             a         b         c ## one 0.8620894 0.7514794 0.7861809 ## two 0.8556624 0.7150163 0.7658788"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"visualizing-a-matching","dir":"Articles","previous_headings":"","what":"Visualizing a matching","title":"Calculate tree similarity with 'TreeDist'","text":"Generalized Robinson–Foulds metrics, variation clustering information, rely matching split within tree another split tree. can view optimal matching:  shows six splits tree 1, paired splits tree two. split labelled measure similarity, contribution total tree similarity score. can view information format accessible examination R : , pairScores attribute lists score possible matching splits. can identify splits : names splits correspond number associated node original tree:  Note strictly, (informative) splits associated (internal) edges. avoid listing split twice, nodes close root (, 10 11) associated split.","code":"VisualizeMatching(ClusteringInfoDistance, tree1, tree2) ClusteringInfoDistance(tree1, tree2, reportMatching = TRUE) ## [1] 6.960578 ## attr(,\"matching\") ## [1] 1 2 3 5 6 4 ## attr(,\"matchedSplits\") ## [1] \"B C D E | A F G H I => B C D H I | A E F G\" ## [2] \"C D E | A B F G H I => C D H I | A B E F G\" ## [3] \"D E | A B C F G H I => D H I | A B C E F G\" ## [4] \"F G H I | A B C D E => E F G | A B C D H I\" ## [5] \"F G | A B C D E H I => F G | A B C D E H I\" ## [6] \"H I | A B C D E F G => H I | A B C D E F G\" ## attr(,\"matchedScores\") ## [1] 0.09109101 0.07278023 0.02475761 0.07278023 0.76420451 0.76420451 ## attr(,\"pairScores\") ##             [,1]        [,2]       [,3]       [,4]       [,5]       [,6] ## [1,] 0.091091008 0.007214618 0.01831078 0.22478751 0.01831078 0.22478751 ## [2,] 0.018310782 0.072780226 0.00000000 0.15200728 0.00000000 0.15200728 ## [3,] 0.002565287 0.002565287 0.02475761 0.09288851 0.02475761 0.09288851 ## [4,] 0.007214618 0.007214618 0.07278023 0.31976006 0.07278023 0.31976006 ## [5,] 0.319760062 0.224787510 0.15200728 0.09288851 0.45810590 0.76420451 ## [6,] 0.224787510 0.319760062 0.45810590 0.76420451 0.15200728 0.09288851 splits <- as.character(TreeTools::as.Splits(tree2)) splits ##                    12                    13                    14  ## \"B C D H I | A F G E\" \"C D H I | A B F G E\" \"D H I | A B C F G E\"  ##                    15                    16                    17  ## \"H I | A B C D F G E\" \"F G E | A B C D H I\" \"F G | A B C D H I E\" oldPar <- par(mar = rep(0, 4)) plot(tree2) ape::nodelabels() ape::nodelabels(splits, as.integer(names(splits)),                  adj = c(1.1, -0.2), cex = 0.8, frame = 'none')"},{"path":"https://ms609.github.io/TreeDist/dev/articles/Using-TreeDist.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Calculate tree similarity with 'TreeDist'","text":"may wish : Provide context tree distances Compare trees different tips Review available distance measures corresponding functions Interpret tree distance metrics Visualize tree landscapes using distance-based tree spaces","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/compare-treesets.html","id":"shiny-app","dir":"Articles","previous_headings":"","what":"Shiny app","title":"Comparing sets of trees from different analyses","text":"can accomplished quickly using MapTrees() graphical user interface: Load trees file: Select first tree file Select appropriate sample size Select Replace existing Load additional set trees file using Add batch existing Display tab, select Point symbols: One per batch, Colour points : Batch","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/compare-treesets.html","id":"scripting-at-the-r-command-line","dir":"Articles","previous_headings":"","what":"Scripting at the R command line","title":"Comparing sets of trees from different analyses","text":"control mapping can obtained command line:  robust analyses (potentially misleading!) 2D plot , consult companion vignette. Note also mapped areas regions overlap may correspond reality; see warnings recommendations Smith (2022a).","code":"# Load trees library(\"TreeTools\", quietly = TRUE) batch1 <- as.phylo(1:60, 8) # Generate 60 similar trees  batch2 <- as.phylo(seq(200, 800, length.out = 30), 8) # A separate batch of 30 trees styles <- c(1, 2) # Select plotting colours / symbols treeStyle <- rep(styles, c(length(batch1), length(batch2)))  # Calculate distances library(\"TreeDist\") distances <- ClusteringInfoDistance(c(batch1, batch2))  # Construct over-simple 2D PCoA mapping mapping <- cmdscale(distances, k = 2) # Plot mapping par(mar = rep(0, 4)) plot(mapping,      asp = 1, # Preserve aspect ratio - do not distort distances      ann = FALSE, axes = FALSE, # Don't label axes: dimensions are meaningless      col = treeStyle, # Colour      pch = treeStyle # Plotting symbol      ) legend(\"left\", c(\"Batch 1\", \"Batch 2\"), col = styles, pch = styles)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/compare-treesets.html","id":"comparing-trees-dispersal-hypervolume","dir":"Articles","previous_headings":"","what":"Comparing trees’ dispersal / hypervolume","title":"Comparing sets of trees from different analyses","text":"Interpreting comparing areas tree space projection can misleading – expanded apparent area Greenland Mercator projection familiar example. , always best work original distances interpreting whether sets trees occupy larger smaller regions tree space.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/compare-treesets.html","id":"distances-from-median","dir":"Articles","previous_headings":"Comparing trees’ dispersal / hypervolume","what":"Distances from median","title":"Comparing sets of trees from different analyses","text":"One approach plot distances median tree:  plotted example, distances median tree greater batch 2 batch 1, indicating dispersed set trees occupies greater hypervolume. Note increased frequency higher distances expected: outer shell sphere contains volume layer equivalent thickness closer centre, phenomenon becomes pronounced dimensionality tree space increases.","code":"# Calculate median trees median1 <- median(batch1) median2 <- median(batch2)  # Compute distance from each tree to the median of its batch dist1 <- ClusteringInfoDist(batch1, median1) dist2 <- ClusteringInfoDist(batch2, median2)  # Set resolution of histogram nBreaks <- 10 breaks <- seq(0, max(dist1, dist2), length.out = nBreaks)  # Plot first distance set hist(dist1, col = \"#00000022\", breaks = breaks,      main = \"Distance from median of batch\",      xlab = \"Clustering information distance\",      ylim = c(0, 25) # Omit this line to infer Y axis limit from first batch.      )  # Add second distance set hist(dist2, col = \"#ff000022\", breaks = breaks, add = TRUE)  # Add legend legend(\"topleft\", c(\"Batch 1\", \"Batch 2\"),        fill = c(\"#00000022\",  \"#ff000022\"))"},{"path":"https://ms609.github.io/TreeDist/dev/articles/compare-treesets.html","id":"consensus-resolution","dir":"Articles","previous_headings":"Comparing trees’ dispersal / hypervolume","what":"Consensus resolution","title":"Comparing sets of trees from different analyses","text":"complementary approach identify resolution consensus batch trees. approach shares many problems Robinson–Foulds distance: particular, resolution can decimated single “rogue” taxon whose position poorly defined (Smith, 2022b). Detecting removing rogue taxa can provide meaningful point comparison.  Whereas direct interpretation analysis straightforward, can provide complementary way understanding distribution trees across tree space.","code":"# Create tree set with a rogue taxon batch3 <- AddTipEverywhere(as.phylo(7, 7), \"t8\")  # Set up plotting area par(mfrow = c(2, 2), mar = rep(0.4, 4))  # Plot naive strict consensus plot(consensus(batch1, p = 1)) plot(consensus(batch3, p = 1))  if (requireNamespace(\"Rogue\", quietly = TRUE)) {   cons1 <- ConsensusWithout(batch1, p = 1,                             Rogue::QuickRogue(batch1, p = 1)[-1, \"taxon\"])   cons3 <- ConsensusWithout(batch3, p = 1,                             Rogue::QuickRogue(batch3, p = 1)[-1, \"taxon\"])      # The information content of each tree gives a measure of its resolution,   # accounting for omitted rogue leaves   SplitwiseInfo(cons1) # 8.5 bits   SplitwiseInfo(cons3) # 15.1 bits: higher resolution indicates that these   # trees are more similar, notwithstanding rogue taxa.      # Plot the trees   plot(cons1)   plot(cons3) } else {   message(\"The package 'Rogue' is required to run this example.\") }"},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/articles/information.html","id":"splits","dir":"Articles","previous_headings":"","what":"Splits","title":"Comparing splits using information theory","text":"internal edge tree represents split divides leaves two partitions. Intuitively, splits instructive others. example, fact mammals reptiles represent two separate groups profound enough worth teaching schoolchildren; much less information represented split identifies two species bat closely related one another mammal reptile.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/information.html","id":"quantifying-information","dir":"Articles","previous_headings":"","what":"Quantifying information","title":"Comparing splits using information theory","text":"can formalize intuition splits contain information others? generally, can quantify amount information? Information usually measured bits. One bit amount information generated tossing fair coin: record outcome coin toss, must record either H T, two symbols equally likely, way compress results multiple tosses. Shannon (1948) information content outcome xx defined h(x)=−log2P(x)h(x) = -\\log_2{P(x)}, simplifies log2n\\log_2{n} nn outcomes equally likely. Thus, outcome fair coin toss delivers log22=1 bit\\log_2{2} = 1\\textrm{ bit} information; outcome rolling fair six-sided die contains log26≈2.58 bits\\log_2{6} \\approx 2.58\\textrm{ bits} information; outcome selecting random one 105 unrooted binary six-leaf trees log2105≈6.71 bits\\log_2{105} \\approx 6.71\\textrm{ bits}. Unlikely outcomes surprising, thus contain information likely outcomes. information content rolling twelve two fair six-sided dice −log2136≈5.16 bits-\\log_2{\\frac{1}{36}} \\approx 5.16\\textrm{ bits}, whereas seven, produced six 36 possible rolls (1 & 6, 2 & 5, …), less surprising, thus contains less information: −log2636≈2.58 bits-\\log_2{\\frac{6}{36}} \\approx 2.58\\textrm{ bits}. additional 2.58 bits information required establish six possible rolls produced seven.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/information.html","id":"application-to-splits","dir":"Articles","previous_headings":"Quantifying information","what":"Application to splits","title":"Comparing splits using information theory","text":"split S1=S_1 =AB|CDEF found 15 105 six-leaf trees; , probability randomly drawn tree contains S1S_1 P(S1)=15105P(S_1) = \\frac{15}{105}, information content h(S1)=−log215105≈2.81 bitsh(S_1) = -\\log_2{\\frac{15}{105}} \\approx 2.81\\textrm{ bits}. Steel & Penny (2006) dub quantity phylogenetic information content. Likewise, split S2=S_2 =ABC|DEF occurs nine 105 six-leaf trees, h(S2)=−log29105≈3.54 bitsh(S_2) = -\\log_2{\\frac{9}{105}} \\approx 3.54\\textrm{ bits}. Three six-leaf trees contain splits, combination splits deliver h(S1,S2)=−log23105≈5.13 bitsh(S_1,S_2) = -\\log_2{\\frac{3}{105}} \\approx 5.13\\textrm{ bits} information. h(S1,S2)<h(S1)+h(S2)h(S_1,S_2) < h(S_1) + h(S_2), information S1S_1 also present S2S_2. information common S1S_1 S2S_2 hshared(S1,S2)=h(S1)+h(S2)−h(S1,S2)≈1.22 bitsh_{shared}(S_1, S_2) = h(S_1) + h(S_2) - h(S_1,S_2) \\approx 1.22\\textrm{ bits}. information unique S1S_1 S2S_2 hdifferent(S1,S2)=2h(S1,S2)−h(S1)−h(S2)≈3.91 bitsh_{different}(S_1,S_2) = 2h(S_1,S_2) - h(S_1) - h(S_2) \\approx 3.91\\textrm{ bits}. quantities can calculated using functions ‘TreeTools’ package.","code":"library(\"TreeTools\", quietly = TRUE) library(\"TreeDist\") treesMatchingSplit <- c(   AB.CDEF = TreesMatchingSplit(2, 4),   ABC.DEF = TreesMatchingSplit(3, 3) ) treesMatchingSplit ## AB.CDEF ABC.DEF  ##      15       9 proportionMatchingSplit <- treesMatchingSplit / NUnrooted(6) proportionMatchingSplit ##    AB.CDEF    ABC.DEF  ## 0.14285714 0.08571429 splitInformation <- -log2(proportionMatchingSplit) splitInformation ##  AB.CDEF  ABC.DEF  ## 2.807355 3.544321 treesMatchingBoth <- TreesConsistentWithTwoSplits(6, 2, 3) combinedInformation <- -log2(treesMatchingBoth / NUnrooted(6))  sharedInformation <- sum(splitInformation) - combinedInformation sharedInformation ## [1] 1.222392 # Or more concisely: SplitSharedInformation(n = 6, 2, 3) ## [1] 1.222392"},{"path":"https://ms609.github.io/TreeDist/dev/articles/information.html","id":"entropy","dir":"Articles","previous_headings":"","what":"Entropy","title":"Comparing splits using information theory","text":"Entropy average information content outcome, weighted probability: ∑−plog2(p)\\sum{-p \\log_2(p)}. nn outcomes equiprobable, simplifies log2n\\log_2{n}. Consider case Jane rolls dice, makes two true statements outcome xx: S1S_1: “roll even?”. Two equally-possible outcomes: yes Entropy: H(S1)=log22=1 bitH(S_1) = \\log_2{2} = 1\\textrm{ bit}. S2S_2: “roll greater 3?” Two equally-possible outcomes: yes Entropy: H(S2)=log22=1 bitH(S_2) = \\log_2{2} = 1\\textrm{ bit}. joint entropy S1S_1 S2S_2 entropy association matrix considers possible outcome: H(S1,S2)=23log223+13log213+13log213+23log223≈1.84 bits\\begin{aligned} H(S_1, S_2) = \\frac{2}{3}\\log_2{\\frac{2}{3}} + \\frac{1}{3}\\log_2{\\frac{1}{3}} + \\frac{1}{3}\\log_2{\\frac{1}{3}} + \\frac{2}{3}\\log_2{\\frac{2}{3}} \\approx 1.84 \\textrm{ bits} \\end{aligned} Note less log26≈2.58 bits\\log_2{6} \\approx 2.58\\textrm{ bits} require determine exact value roll: knowledge S1S_1 S2S_2 guaranteed sufficient unambiguously identify xx. mutual information S1S_1 S2S_2 describes much knowledge S1S_1 reduces uncertainty S2S_2 (vice versa). learn S1S_1 ‘even’, become little confident S2S_2 ‘greater three’. mutual information (S1;S2)(S_1;S_2), denoted blue , corresponds sum individual entropies, minus joint entropy: two statements high mutual information, heard one statement, already good idea outcome statement , thus learn little new hearing . entropy distance, also termed variation information (Meila, 2007), corresponds information S1S_1 S2S_2 common (denoted yellow): higher entropy distance, harder predict outcome one statement ; maximum entropy distance occurs two statements entirely independent.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/information.html","id":"application-to-splits-1","dir":"Articles","previous_headings":"Entropy","what":"Application to splits","title":"Comparing splits using information theory","text":"split divides leaves two partitions. arbitrarily label partitions ‘’ ‘B’, select leaf random, can view partition label associated leaf. 60/100 leaves belong partition ‘’, 40/100 ‘B’, leaf drawn random 40% chance bearing label ‘’; split entropy −60100log260100−40100log240100≈0.97 bits-\\frac{60}{100}\\log_2{\\frac{60}{100}}-\\frac{40}{100}\\log_2{\\frac{40}{100}} \\approx 0.97\\textrm{ bits}. Now consider different split, perhaps different tree, assigns 50 leaves ‘’ partition ‘C’, leaving remaining 10 leaves ‘’, along 40 ‘B’, partition ‘D’. split −50100log250100−50100log250100=1 bit-\\frac{50}{100}\\log_2{\\frac{50}{100}}-\\frac{50}{100}\\log_2{\\frac{50}{100}} = 1\\textrm{ bit} entropy. Put together, randomly selected leaf may now bear one three possible labellings: ‘’ ‘C’: 50 leaves ‘’ ‘D’: 10 leaves ‘B’ ‘D’: 40 leaves. two splits thus joint entropy −50100log250100−10100log210100−40100log240100≈1.36 bits<0.97+1-\\frac{50}{100}\\log_2{\\frac{50}{100}} -\\frac{10}{100}\\log_2{\\frac{10}{100}} -\\frac{40}{100}\\log_2{\\frac{40}{100}} \\approx 1.36\\textrm{ bits} < 0.97 + 1. joint entropy less sum individual entropies two splits contain mutual information: instance, leaf bears label ‘B’, can certain also bear label ‘D’. similar splits , agree division leaves, mutual information exhibit. term clustering information, contradistinction concept phylogenetic information discussed . formally, let split SS divides nn leaves two partitions AA BB. probability randomly chosen leaf xx partition kk P(x∈k)=|k|nP(x \\k) = \\frac{|k|}{n}. SS thus corresponds random variable entropy H(S)=−||nlog2||n−|B|nlog2|B|nH(S) = -\\frac{||}{n} \\log_2{\\frac{||}{n}} - \\frac{|B|}{n}\\log_2{\\frac{|B|}{n}}(Meila, 2007). joint entropy two splits, S1S_1 S2S_2, corresponds entropy association matrix probabilities randomly selected leaf belongs pair partitions: H(S1,S2)=P(A1,A2)log2P(A1,A2)+P(B1,A2)log2P(B1,A2)H(S_1, S_2) = P(A_1,A_2) \\log_2 {P(A_1,A_2)} + P(B_1,A_2) \\log_2 {P(B_1,A_2)} +P(A1,B2)log2P(A1,B2)+P(B1,B2)log2P(B1,B2)+ P(A_1,B_2)\\log_2{P(A_1,B_2)} + P(B_1,B_2)\\log_2{P(B_1,B_2)} values can substituted definitions mutual information entropy distance given . S1S_1 S2S_2 become different, disposition S1S_1 gives less information configuration S2S_2, mutual information decreases accordingly.","code":""},{"path":[]},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"tree-space-analysis-via-user-interface","dir":"Articles","previous_headings":"","what":"Tree space analysis via user interface","title":"Tree space analysis","text":"Tree space mapping analysis made simple Shiny app included “TreeDist” R package. Simply install R RStudio, copy code R command line: allow conduct evaluate basic tree space mappings tree lists saved common file formats; see outline basic functionality. avoid misinterpreting tree space, ’s worth broad idea analysis involves, potential pitfalls.","code":"install.packages(\"TreeDist\") TreeDist::MapTrees()"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"avoiding-common-pitfalls-in-tree-space-analysis","dir":"Articles","previous_headings":"","what":"Avoiding common pitfalls in tree space analysis","title":"Tree space analysis","text":"’s example analysis series 200 trees ordered list. list corresponds mixed-base representation trees (see TreeTools::.TreeNumber()), expected contain structure jump one “class” tree another. Let’s see whether can visualize corroborate structure. First ’ll generate trees, load colours might identify .","code":"library(\"TreeTools\", quietly = TRUE) treeNumbers <- c(1:220) trees <- as.phylo(treeNumbers, 8) spectrum <- hcl.colors(220, \"plasma\") treeCols <- spectrum[treeNumbers]"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"using-a-suitable-distance-metric","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Using a suitable distance metric","title":"Tree space analysis","text":"Now need calculate distance pair trees list. choice distance metric important (M. R. Smith, 2022). widely used Robinson–Foulds distance , unfortunately, unsuitable tree space analysis. clustering information distance (M. R. Smith, 2020) reliable alternative fast calculate: reader encouraged repeat exercise distances:","code":"library(\"TreeDist\") distances <- ClusteringInfoDistance(trees) distances <- RobinsonFoulds(trees) distances <- PhylogeneticInfoDistance(trees) distances <- as.dist(Quartet::QuartetDivergence(   Quartet::ManyToManyQuartetAgreement(trees), similarity = FALSE))"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"mapping-distances","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Mapping distances","title":"Tree space analysis","text":"need reduce dimensionality distances. ’ll start 12-dimensional mapping; needed, can always drop higher dimensions. Principal coordinates analysis quick performs well: Alternative mapping methods exist, sometimes give slightly better mappings. isoMDS() performs non-metric multidimensional scaling (MDS) Kruskal-1 stress function (Kruskal, 1964): whereas sammon(), one many metric MDS methods, uses Sammon’s stress function (Sammon, 1969): ’s good start. tempting plot first two dimensions arising mapping done:","code":"mapping <- cmdscale(distances, k = 12) kruskal <- MASS::isoMDS(distances, k = 12) mapping <- kruskal$points sammon <- MASS::sammon(distances, k = 12) mapping <- sammon$points par(mar = rep(0, 4)) plot(mapping,      asp = 1, # Preserve aspect ratio - do not distort distances      ann = FALSE, axes = FALSE, # Don't label axes: dimensions are meaningless      col = treeCols, pch = 16      )"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"identifying-clusters","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Identifying clusters","title":"Tree space analysis","text":"quick visual inspection suggests least two clusters, possibility subdivision brighter trees. visual inspection can highly misleading (M. R. Smith, 2022). must take statistical approach. combination partitioning around medoids hierarchical clustering minimax linkage typically find clustering solution close optimal, one exists (M. R. Smith, 2022); suitably initialized, k-means++ clustering (Arthur & Vassilvitskii, 2007) can also worthwhile.  Silhouette coefficients < 0.25 suggest structure meaningful; > 0.5 denotes good evidence clustering, > 0.7 strong evidence (Kaufman & Rousseeuw, 1990). evidence visually apparent clustering strong first appears. Let’s explore two-cluster hierarchical clustering solution anyway. can visualize clustering solution tree:  Another thing may wish take consensus cluster:  , learn two clusters distinguished position t7.","code":"possibleClusters <- 2:10  # Partitioning around medoids pamClusters <- lapply(possibleClusters, function(k) cluster::pam(distances, k = k)) pamSils <- vapply(pamClusters, function(pamCluster) {   mean(cluster::silhouette(pamCluster)[, 3]) }, double(1))  bestPam <- which.max(pamSils) pamSil <- pamSils[bestPam] pamCluster <- pamClusters[[bestPam]]$cluster  # Hierarchical clustering hTree <- protoclust(distances) hClusters <- lapply(possibleClusters, function(k) cutree(hTree, k = k)) hSils <- vapply(hClusters, function(hCluster) {   mean(cluster::silhouette(hCluster, distances)[, 3]) }, double(1))  bestH <- which.max(hSils) hSil <- hSils[bestH] hCluster <- hClusters[[bestH]]  # k-means++ clustering kClusters <- lapply(possibleClusters, function(k) KMeansPP(distances, k = k)) kSils <- vapply(kClusters, function(kCluster) {   mean(cluster::silhouette(kCluster$cluster, distances)[, 3]) }, double(1))  bestK <- which.max(kSils) kSil <- kSils[bestK] kCluster <- kClusters[[bestK]]$cluster  plot(pamSils ~ possibleClusters,      xlab = \"Number of clusters\", ylab = \"Silhouette coefficient\",      ylim = range(c(pamSils, hSils))) points(hSils ~ possibleClusters, pch = 2, col = 2) points(kSils ~ possibleClusters, pch = 3, col = 3) legend(\"topright\", c(\"PAM\", \"Hierarchical\", \"k-means++\"),        pch = 1:3, col = 1:3) nClusters <- 2 whichResult <- match(nClusters, possibleClusters) cluster <- hClusters[[whichResult]] class(hTree) <- \"hclust\" par(mar = c(0, 0, 0, 0)) plot(hTree, labels = FALSE, main = \"\") points(seq_along(trees), rep(1, length(trees)), pch = 16,        col = spectrum[hTree$order]) par(mfrow = c(1, 2), mar = rep(0.2, 4)) col1 <- spectrum[mean(treeNumbers[cluster == 1])] col2 <- spectrum[mean(treeNumbers[cluster == 2])] plot(consensus(trees[cluster == 1], p = 0.5),      edge.color = col1, edge.width = 2, tip.color = col1) plot(consensus(trees[cluster == 2], p = 0.5),      edge.color = col2, edge.width = 2, tip.color = col2)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"identifying-islands","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Identifying islands","title":"Tree space analysis","text":"Besides clustering, can also define ‘islands’ tree space separated ‘moat’, trees one island separated trees another least certain distance (Silva & Wilkinson, 2021).  Let’s view consensus large island cluster:","code":"par(mar = rep(0, 4)) # set a threshold corresponding to the width of the \"moat\" between islands threshold <- 1.8 island <- Islands(distances, threshold)  # See how many trees are on each island table(island) ## island ##  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  ## 89  3  3  3  3  3  3  3  3  3  3 57  1  1  3  2  1  1  3  1  1  3  1  3  3  3  ## 27 28 29 30 31 32 33 34 35 36  ##  3  3  1  1  1  1  2  3  1  1 # Let's ignore the small islands for now largeIsle <- Islands(distances, threshold, smallest = 5)  # Colour trees according to their island plot(mapping,      asp = 1, # Preserve aspect ratio - do not distort distances      ann = FALSE, axes = FALSE, # Don't label axes: dimensions are meaningless      col = ifelse(is.na(largeIsle), \"grey\", largeIsle + 1),      pch = 16      ) par(mfrow = c(1, 2), mar = rep(0.2, 4)) plot(consensus(trees[!is.na(largeIsle) & largeIsle == 1], p = 0.5),      edge.color = 2, edge.width = 2, tip.color = 2) plot(consensus(trees[!is.na(largeIsle) & largeIsle == 2], p = 0.5),      edge.color = 3, edge.width = 2, tip.color = 3)"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"validating-a-mapping","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Validating a mapping","title":"Tree space analysis","text":"Now let’s evaluate whether map tree space representative. First want know many dimensions necessary adequately represent true distances trees. hope trustworthiness × continuity score > 0.9 usable mapping, > 0.95 good one.  going need least five dimensions adequately represent distances trees. help establish visually structures likely genuine, might also choose calculate minimum spanning tree: Let’s plot first five dimensions tree space, highlighting convex hulls clusters:  clusters, distinct dimension 1, overlap strongly every dimension. fact minimum spanning tree moves clusters also underlines fact well defined appear eye. Note cluster membership, well precise shape tree space, function tree distance metric. phylogenetic information distance recovers different pair clusters, may correspond apparent simple visual inspection two-dimensional tree space plot:","code":"txc <- vapply(seq_len(ncol(mapping)), function(k) {   newDist <- dist(mapping[, seq_len(k)])   MappingQuality(distances, newDist, 10)[\"TxC\"] }, 0) plot(txc, xlab = \"Dimension\") abline(h = 0.9, lty = 2) mstEnds <- MSTEdges(distances) nDim <- which.max(txc > 0.9) plotSeq <- matrix(0, nDim, nDim) plotSeq[upper.tri(plotSeq)] <- seq_len(nDim * (nDim - 1) / 2) plotSeq <- t(plotSeq[-nDim, -1]) plotSeq[nDim * 1:3] <- (nDim * (nDim - 1) / 2) + 1:3 layout(plotSeq) par(mar = rep(0.1, 4))  for (i in 2:nDim) for (j in seq_len(i - 1)) {   # Set up blank plot   plot(mapping[, j], mapping[, i], ann = FALSE, axes = FALSE, frame.plot = TRUE,        type = \"n\", asp = 1, xlim = range(mapping), ylim = range(mapping))      # Plot MST   MSTSegments(mapping[, c(j, i)], mstEnds,               col = StrainCol(distances, mapping[, c(j, i)]))      # Add points   points(mapping[, j], mapping[, i], pch = 16, col = treeCols)    # Mark clusters   for (clI in unique(cluster)) {     inCluster <- cluster == clI     clusterX <- mapping[inCluster, j]     clusterY <- mapping[inCluster, i]     hull <- chull(clusterX, clusterY)     polygon(clusterX[hull], clusterY[hull], lty = 1, lwd = 2,             border = \"#54de25bb\")     text(mean(clusterX), mean(clusterY), clI, col = \"#54de25bb\", font = 2)   } } # Annotate dimensions plot(0, 0, type = \"n\", ann = FALSE, axes = FALSE) text(0, 0, \"Dimension 2\") plot(0, 0, type = \"n\", ann = FALSE, axes = FALSE) text(0, 0, \"Dimension 3\") plot(0, 0, type = \"n\", ann = FALSE, axes = FALSE) text(0, 0, \"Dimension 4\")"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"comparing-cluster-size","dir":"Articles","previous_headings":"Avoiding common pitfalls in tree space analysis","what":"Comparing cluster size","title":"Tree space analysis","text":"tempting compare size clusters calculating area convex hulls two-dimensional mapping. However, mapped areas necessarily correspond true hypervolumes. Accuracy may improved comparing higher dimensions projections using “hypervolume” package, though considerations apply (Blonder et al., 2018). Interpretation overlap statistics detailed Mammola (2019). objective quantify spread different clusters, metrics may easier interpret clusters’ hypervolume (e.g. T. J. Smith & Donoghue (2022)). divergence outlying points can measures using sum ranges: overall size cluster can measured using sum variances, mean distance centroid median: density points within cluster can measured using mean nearest-neighbour distance mean minimum spanning tree edge length:","code":"hypervolumeInstalled <- requireNamespace(\"hypervolume\", quietly = TRUE) if (hypervolumeInstalled) {   library(\"hypervolume\")   hv1 <- hypervolume_gaussian(pid_mapping[pid_cluster == 1, 1:3],                               verbose = FALSE)   hv2 <- hypervolume_gaussian(pid_mapping[pid_cluster == 2, 1:3],                               verbose = FALSE)   hv_dist <- hypervolume_distance(hv1, hv2)   capture.output(     hyperset <- hypervolume_set(hv1, hv2, verbose = FALSE,                               check.memory = FALSE)   ) -> XX_VerboseNotRespected   hv_overlap <- hypervolume_overlap_statistics(hyperset)   hv_dist   hv_overlap } else {   print(\"Install the 'hypervolume' package to run this example\") } ##       jaccard      sorensen frac_unique_1 frac_unique_2  ##    0.02648093    0.05159556    0.94582792    0.95074700 SumOfRanges(pid_mapping, pid_cluster) ## [1] 132.0758 127.3610 SumOfVariances(pid_mapping, pid_cluster) ## [1] 173.0981 176.8212 MeanCentroidDistance(pid_mapping, pid_cluster) ## [1] 12.58064 12.80727 DistanceFromMedian(pid_mapping, pid_cluster) ## [1] 13.42931 13.48348 MeanNN(pid_mapping, pid_cluster) ## [1] 4.676416 5.274230 MeanMSTEdge(pid_mapping, pid_cluster) ## [1] 5.558778 5.804829"},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"self-organizing-maps","dir":"Articles","previous_headings":"","what":"Self-organizing maps","title":"Tree space analysis","text":"alternative approach visualizing tree space create emergent self-organizing maps (Kohonen, 1982; Thrun, Lerch, Lötsch, & Ultsch, 2016; Ultsch, 2003), map high-dimensional data two dimensions, add third dimension indicate distance data points: nearby points occur valleys, separated ridges distant data points.","code":"umatrixInstalled <- requireNamespace(\"Umatrix\", quietly = TRUE) if (umatrixInstalled) {   map <- Umatrix::esomTrain(as.matrix(distances), Key = seq_along(trees),                             Epochs = 5, # Increase for better results                             Lines = 42,                             Columns = 42,                             Toroid = FALSE)      Umatrix::plotMatrix(Matrix = map$Umatrix,                       Toroid = FALSE, FixedRatio = TRUE,                       TransparentContours = FALSE, Clean = TRUE) +   ggplot2::geom_point(data = data.frame(x = map$BestMatches[, 3],                                         y = map$BestMatches[, 2]),                       shape = 19, color = treeCols, size = 2)  } else {   message(\"Install the 'Umatrix' package to run this example\") } ## [1] \"Epoch: 1 started\" ## [1] \"Epoch: 1 finished. 220 datapoints changed bestmatch\" ## [1] \"Epoch: 2 started\" ## [1] \"Epoch: 2 finished. 216 datapoints changed bestmatch\" ## [1] \"Epoch: 3 started\" ## [1] \"Epoch: 3 finished. 212 datapoints changed bestmatch\" ## [1] \"Epoch: 4 started\" ## [1] \"Epoch: 4 finished. 203 datapoints changed bestmatch\" ## [1] \"Epoch: 5 started\" ## [1] \"Epoch: 5 finished. 165 datapoints changed bestmatch\" ## [1] \"---- Esom Training Finished ----\""},{"path":"https://ms609.github.io/TreeDist/dev/articles/treespace.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Tree space analysis","text":"may wish : Analyse landscapes phylogenetic trees Provide context tree distances Review available distance measures corresponding functions Interpret tree distance metrics Compare distribution different sets trees","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"normalizing","dir":"Articles","previous_headings":"","what":"Normalizing","title":"Contextualizing tree distances","text":"maximum value tree distance metrics scales size trees compared. Typically, resolution trees also impacts range possible values. , can difficult interpret tree distance value without suitable context. Normalizing distance metric one way render meaning obvious. Selecting appropriate normalizing constant may require careful consideration purpose tree distance metric put. default normalization behaviour function normalize = TRUE listed function reference, can viewed typing ?FunctionName R terminal.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"nye-et-al--tree-similarity","dir":"Articles","previous_headings":"Normalizing","what":"Nye et al. tree similarity","title":"Contextualizing tree distances","text":"Let’s work simple example using Nye et al. (2006) similarity metric compare two imperfectly-resolved trees.  nice metric start , maximum similarity pair splits defined one. (Astute readers might worry minimum similarity greater zero – ’s harder problem overcome.) , maximum similarity possible two 11-leaf trees NSplits(11) = 8. Normalizing value tells us similar two trees , compared two identical eleven-leaf binary trees. approach result similarity score less one two trees identical, fully resolved (.e. binary). , might prefer compare tree similarity maximum score possible two trees specified resolution. value given number splits least resolved two trees: concisely, can provide normalizing function: approach produce similarity one one tree less-resolved version another (thus identical). comparing lists trees, best value depend number splits pair trees. can use function pmin() select less resolved pair trees: avoid limitations, may instead opt normalize average number splits two trees. default normalization method NyeSimilarity(): Finally, tree1 “target” tree – perhaps one used simulate data , independently known true virtuous – may wish normalize best possible match tree. case, best possible score normalized score ","code":"library(\"TreeDist\") tree1 <- ape::read.tree(text = '(A, ((B, ((C, D), (E, F))), (G, (H, (I, J, K)))));') tree2 <- ape::read.tree(text = '(A, (B, (C, D, E, (J, K)), (F, (G, H, I))));') VisualizeMatching(NyeSimilarity, tree1, tree2,                   Plot = TreeDistPlot, matchZeros = FALSE) NyeSimilarity(tree1, tree2, normalize = FALSE) / 8 ## [1] 0.2744048 NyeSimilarity(tree1, tree2, normalize = 8) ## [1] 0.2744048 NyeSimilarity(tree1, tree2,                   normalize = min(TreeTools::NSplits(list(tree1, tree2)))) ## [1] 0.5488095 NyeSimilarity(tree1, tree2, normalize = min) ## [1] 0.2744048 NyeSimilarity(list(tree1, tree2), list(tree1, tree2), normalize = pmin) ##           [,1]      [,2] ## [1,] 0.8750000 0.2744048 ## [2,] 0.2744048 0.5000000 NyeSimilarity(tree1, tree2, normalize = TRUE) ## [1] 0.3991342 TreeTools::NSplits(tree1) ## [1] 7 NyeSimilarity(tree1, tree2, normalize = TreeTools::NSplits(tree1)) ## [1] 0.3136054"},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"normalizing-to-random-similarity","dir":"Articles","previous_headings":"Normalizing","what":"Normalizing to random similarity","title":"Contextualizing tree distances","text":"diameter (maximum possible distance) Nye et al. tree similarity metric easy calculate, case metrics. example, clustering information distance metric (Smith, 2020) ranges principle zero total clustering entropy present pair trees. even modest number leaves, pairs trees exist every split one tree perfectly contradicted every split ; , pair trees necessarily degree similarity. context, can relevant normalize tree similarity expected distance pair random trees, rather maximum value (see Vinh, Epps, & Bailey, 2010). measure, distances greater one denote trees different expected chance, whereas distance zero denotes identity. quartet divergence, expected tree distance readily calculated: given quartet one three chance matching chance. expected distance difficult calculate metrics, can approximated sampling random pairs trees. Measured distances 10 000 pairs random bifurcating trees 200 leaves available data package ‘TreeDistData’. can view (normalized) distances selection methods:  use calculated values normalize tree distance:","code":"library(\"Quartet\", exclude = \"RobinsonFoulds\") expectedQD <- 2 / 3 normalizedQD <- QuartetDivergence(QuartetStatus(tree1, tree2),                                   similarity = FALSE) / expectedQD if (requireNamespace(\"TreeDistData\", quietly = TRUE)) {   library(\"TreeDistData\", exclude = \"PairwiseDistances\")   data(\"randomTreeDistances\", package = \"TreeDistData\")      methods <- c(\"pid\", \"cid\", \"nye\", \"qd\")   methodCol <- c(pid = \"#e15659\", cid = \"#58a14e\", nye = \"#edc949\",                  qd = \"#af7aa1\")      oldPar <- par(cex = 0.7, mar = c(5, 5, 0.01, 0.01))   nLeaves <- as.integer(dimnames(randomTreeDistances)[[3]])   plot(nLeaves, type = \"n\", randomTreeDistances[\"pid\", \"mean\", ],        ylim = c(0.54, 1),        xlab = \"Number of leaves\",        ylab = \"Normalized distance between random tree pairs\")      for (method in methods) {     dat <- randomTreeDistances[method, , ]     lines(nLeaves, dat[\"50%\", ], pch = 1, col = methodCol[method])     polygon(c(nLeaves, rev(nLeaves)), c(dat[\"25%\", ], rev(dat[\"75%\", ])),             border = NA, col = paste0(methodCol[method], \"55\"))        }      text(202, randomTreeDistances[methods, \"50%\", \"200\"] + 0.02,         c(\"Different phylogenetic information\",           \"Clustering information distance\",          expression(paste(plain(\"Nye \"), italic(\"et al.\"))),          \"Quartet divergence\"          ), col = methodCol[methods], pos = 2)   par(oldPar) } expectedCID <- randomTreeDistances[\"cid\", \"mean\", \"9\"] ClusteringInfoDistance(tree1, tree2, normalize = TRUE) / expectedCID"},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"testing-similarity-to-a-known-tree","dir":"Articles","previous_headings":"","what":"Testing similarity to a known tree","title":"Contextualizing tree distances","text":"Similarity two components: precision accuracy (Smith, 2019). tree can 80% similar target tree contains 80% splits target tree, incorrect splits – binary tree 10% splits present resolved incorrectly thus positively misleading. comparison, course, sensible talk split information just number splits: even split may contain information two uneven splits, absence two information-poor splits may preferable absence one information-rich split. , instructive think proportion information correctly resolved: goal find tree informative possible true tree. Ternary diagrams allow us visualise quality reconstructed tree reference known “true” tree:    Better trees plot vertically towards “100% shared information” vertex. Resolution trees increases towards right; trees resolved may better less-resolved trees addition resolution introduces error.","code":"testTrees <- list(   trueTree = ape::read.tree(text = '(a, (b, (c, (d, (e, (f, (g, h)))))));'),   lackRes = ape::read.tree(text = '(a, (b, c, (d, e, (f, g, h))));'),   smallErr = ape::read.tree(text = '(a, (c, (b, (d, (f, (e, (g, h)))))));'),   bigErr = ape::read.tree(text = '(a, (c, (((b, d), (f, h)), (e, g))));') ) VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$lackRes) points(4, 7.5, pch = 2, cex = 3, col = \"#E69F00\", xpd = NA) VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$smallErr) points(4, 7.5, pch = 3, cex = 3, col = \"#56B4E9\", xpd = NA) VisualizeMatching(MutualClusteringInfo, testTrees$trueTree, testTrees$bigErr) points(4, 7.5, pch = 4, cex = 3, col = \"#009E73\", xpd = NA) if (requireNamespace(\"Ternary\", quietly = TRUE)) {   library(\"Ternary\")   oldPar <- par(mar = rep(0.1, 4))   TernaryPlot(alab = \"Absent information\", blab = \"Shared information\",               clab = \"Misinformation\",               lab.cex = 0.8, lab.offset = 0.18,               point = \"left\", clockwise = FALSE,               grid.col = \"#dedede\", grid.minor.lines = 0,               axis.labels = 0:10 / 10, axis.col = \"#aaaaaa\")      HorizontalGrid()   correct <- MutualClusteringInfo(testTrees$trueTree, testTrees)   resolved <- ClusteringEntropy(testTrees)   unresolved <- resolved[\"trueTree\"] - resolved   incorrect <- resolved - correct   TernaryPoints(cbind(unresolved, correct, incorrect),                  pch = 1:4, cex = 2, col = Ternary::cbPalette8[1:4])   par(oldPar) }"},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"example","dir":"Articles","previous_headings":"Testing similarity to a known tree","what":"Example","title":"Contextualizing tree distances","text":"’s noddy real-world example applying simulation-style study. First, let’s generate starting tree, represent reference topology: , let’s generate 200 degraded trees. ’ll move away true tree making TBR move, reduce resolution taking consensus tree three trees immediate neighbourhood (one NNI move away). let’s generate 200 trees even degraded. time ’ll move (three TBR moves) true tree, reduce resolution taking consensus three trees wider neighbourhood (two NNI moves away). Now let’s calculate tree similarity scores. need calculate amount information tree common true tree: amount information degraded tree: amount information resolved, : amount information incorrectly resolved: preparation plot, let’s colour one-away trees  orange , three-away trees  blue : Now can plot information ternary diagram.  ternary plot, vertical direction corresponds normalized tree quality, depicted accompanying histogram.","code":"set.seed(0) trueTree <- TreeTools::RandomTree(20, root = TRUE) treeSearchInstalled <- requireNamespace(\"TreeSearch\", quietly = TRUE) if (treeSearchInstalled) {   library(\"TreeSearch\", quietly = TRUE) # for TBR, NNI   oneAway <- structure(lapply(seq_len(200), function(x) {     tbrTree <- TBR(trueTree)     ape::consensus(list(tbrTree,                         NNI(tbrTree),                         NNI(tbrTree),                         NNI(tbrTree)))   }), class = \"multiPhylo\") } else {   message(\"Install \\\"TreeSearch\\\" to run this example\") } if (treeSearchInstalled) {   threeAway <- structure(lapply(seq_len(200), function(x) {     tbrTree <- TBR(TBR(TBR(trueTree)))     ape::consensus(list(tbrTree,                          NNI(NNI(tbrTree)),                         NNI(NNI(tbrTree)),                         NNI(NNI(tbrTree))))   }), class = \"multiPhylo\") } if (treeSearchInstalled) {   correct1 <- MutualClusteringInfo(trueTree, oneAway)   correct3 <- MutualClusteringInfo(trueTree, threeAway) } if (treeSearchInstalled) {   infoInTree1 <- ClusteringEntropy(oneAway)   infoInTree3 <- ClusteringEntropy(threeAway) } if (treeSearchInstalled) {   unresolved1 <- ClusteringEntropy(trueTree) - infoInTree1   unresolved3 <- ClusteringEntropy(trueTree) - infoInTree3 } if (treeSearchInstalled) {   incorrect1 <- infoInTree1 - correct1   incorrect3 <- infoInTree3 - correct3 } col1 <- hcl(200, alpha = 0.9) col3 <- hcl(40, alpha = 0.9) spec1 <- matrix(col2rgb(col1, alpha = TRUE), nrow = 4, ncol = 181) spec3 <- matrix(col2rgb(col3, alpha = TRUE), nrow = 4, ncol = 181) spec1[4, ] <- spec3[4, ] <- 0:180 ColToHex <- function(x) rgb(x[1], x[2], x[3], x[4], maxColorValue = 255) spec1 <- apply(spec1, 2, ColToHex) spec3 <- apply(spec3, 2, ColToHex) if (treeSearchInstalled && requireNamespace(\"Ternary\", quietly = TRUE)) {   layout(matrix(c(1, 2), ncol = 2), widths = c(5, 2))   oldPar <- par(mar = rep(0, 4))   TernaryPlot(alab = \"Information absent in degraded tree\",                blab = \"\\n\\nCorrect information in degraded tree\",                clab = \"Misinformation in degraded tree\",               point = \"left\", clockwise = FALSE, grid.minor.lines = 0,               axis.labels = 0:10 / 10)      HorizontalGrid()      coords1 <- cbind(unresolved1, correct1, incorrect1)   coords3 <- cbind(unresolved3, correct3, incorrect3)      ColourTernary(TernaryDensity(coords1, resolution = 20), spectrum = spec1)   ColourTernary(TernaryDensity(coords3, resolution = 20), spectrum = spec3)      TernaryDensityContour(coords3, col = col3, nlevels = 4)   TernaryDensityContour(coords1, col = col1, nlevels = 4)      if (requireNamespace(\"kdensity\", quietly = TRUE)) {     library(\"kdensity\")     HorizontalKDE <- function(dat, col, add = FALSE) {       lty <- 1       lwd <- 2       kde <- kdensity(dat)       kdeRange <- kdensity:::get_range(kde)       if (add) {         lines(kde(kdeRange), kdeRange, col = col, lty = lty, lwd = lwd)       } else {         plot(kde(kdeRange), kdeRange, col = col, lty = lty, lwd = lwd,               ylim = c(0, 1), main = \"\", axes = FALSE, type = \"l\")       }       # abline(h = 0:10 / 10) # Useful for confirming alignment     }        par(mar = c(1.8, 0, 1.8, 0)) # align plot limits with ternary plot     HorizontalKDE(correct1 / infoInTree1, col1, add = FALSE)     HorizontalKDE(correct3 / infoInTree3, col3, add = TRUE)     mtext(\"\\u2192 Normalized tree quality \\u2192\", 2)   }   par(oldPar) } else {   message(\"Install \\\"TreeSearch\\\" and \\\"Ternary\\\" to generate this plot\") }"},{"path":"https://ms609.github.io/TreeDist/dev/articles/using-distances.html","id":"what-next","dir":"Articles","previous_headings":"","what":"What next?","title":"Contextualizing tree distances","text":"may wish : Explore Ternary package Interpret tree distance metrics Compare trees different tips Review available distance measures corresponding TreeDist functions Construct tree spaces visualize landscapes phylogenetic trees","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin R. Smith. Author, maintainer, copyright holder, programmer. Roy Jonker. Programmer, copyright holder. Yong Yang. Contributor, copyright holder. Yi Cao. Contributor, copyright holder.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith, M.R. (2020a). Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees. Bioinformatics 36: 5007–5013. doi: 10.1093/bioinformatics/btaa614 Smith, M.R. (2022). Robust analysis phylogenetic tree space. Systematic Biology 71: 1255–1270. doi: 10.1093/sysbio/syab100 Smith, M.R. (2020b). TreeDist: Distances Phylogenetic Trees. R package version 2.9.2.9000. Comprehensive R Archive Network. doi:10.5281/zenodo.3528124","code":"@Article{Smith2020,   doi = {10.1093/bioinformatics/btaa614},   title = {Information theoretic Generalized Robinson-Foulds metrics for comparing phylogenetic trees},   author = {Martin R. Smith},   journal = {Bioinformatics},   volume = {36},   number = {20},   pages = {5007–5013},   year = {2020}, } @Article{Smith2022,   doi = {10.1093/sysbio/syab100},   title = {Robust analysis of phylogenetic tree space},   author = {Martin R. Smith},   journal = {Systematic Biology},   volume = {71},   number = {5},   pages = {1255-1270},   year = {2022}, } @Manual{TreeDist,   title = {TreeDist: Distances between Phylogenetic Trees. R package version 2.9.2.9000},   author = {Martin R. Smith},   doi = {10.5281/zenodo.3528124},   journal = {Comprehensive R Archive Network},   year = {2020}, }"},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":null,"dir":"","previous_headings":"","what":"TreeDist R Package Development","title":"TreeDist R Package Development","text":"TreeDist R package providing efficient implementations functions comparison phylogenetic trees. includes C++ code performance, comprehensive testing, benchmarking infrastructure, extensive CI/CD workflows. Correctness, speed user-friendliness priorities. Always reference instructions first fallback search bash commands encounter unexpected information match info .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"bootstrap-and-development-setup","dir":"","previous_headings":"Working Effectively","what":"Bootstrap and Development Setup","title":"TreeDist R Package Development","text":"Install R development tools: Install R development packages: Install TreeDist dependencies:","code":"sudo apt update && sudo apt install -y r-base r-base-dev build-essential sudo apt install -y libcurl4-openssl-dev libssl-dev libxml2-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev sudo R -e \"install.packages(c('devtools', 'testthat', 'roxygen2', 'lintr'), repos='https://cran.r-project.org/')\" sudo R -e \"install.packages(c('ape', 'bit64', 'lifecycle', 'colorspace', 'fastmatch', 'RCurl', 'R.cache', 'Rdpack', 'stringi', 'PlotTools', 'TreeTools'), repos='https://cran.r-project.org/', dependencies=TRUE)\""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"building-and-checking","dir":"","previous_headings":"Working Effectively","what":"Building and Checking","title":"TreeDist R Package Development","text":"NEVER CANCEL: R package builds can take 10-30+ minutes depending dependencies system performance. Set timeout 60+ minutes. Build package: NEVER CANCEL: Full R CMD check takes 15-45+ minutes. Set timeout 90+ minutes. Check package (full validation): Quick check (development, ~2-5 minutes):","code":"R CMD build . R CMD check TreeDist_*.tar.gz R CMD check --no-build-vignettes --no-manual ."},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"testing","dir":"","previous_headings":"Working Effectively","what":"Testing","title":"TreeDist R Package Development","text":"NEVER CANCEL: Test suite 61+ test files can take 10-30+ minutes. Set timeout 60+ minutes. Run tests: Run tests testthat directly: Run specific test file:","code":"R -e \"devtools::test()\" R -e \"testthat::test_dir('tests/testthat')\" R -e \"testthat::test_file('tests/testthat/test-tree_display.R')\""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"development-workflow-commands","dir":"","previous_headings":"Working Effectively","what":"Development Workflow Commands","title":"TreeDist R Package Development","text":"Load package development: Check code style (~1-2 minutes): Build documentation: NEVER CANCEL: Build vignettes takes 5-15+ minutes. Set timeout 30+ minutes. Build vignettes:","code":"R -e \"devtools::load_all()\" R -e \"lintr::lint_dir('.')\" R -e \"devtools::document()\" R -e \"devtools::build_vignettes(install = FALSE)\""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"validation","dir":"","previous_headings":"","what":"Validation","title":"TreeDist R Package Development","text":"Always run R CMD check complete validation finalizing changes. ALWAYS run full test suite modifying C++ code src/ directory. ALWAYS run lintr ensure code style compliance committing. performance-critical changes, run benchmarks benchmark/ directory: Memory checking available optional (takes significant time):","code":"R -e \"source('benchmark/_run_benchmarks.R')\" R -d \"valgrind --tool=memcheck --leak-check=full\" --vanilla < memcheck/tests.R"},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"validation-scenarios","dir":"","previous_headings":"","what":"Validation Scenarios","title":"TreeDist R Package Development","text":"making code changes, validate functionality testing core phylogenetic tree operations:","code":""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"time-expectations--critical-warnings","dir":"","previous_headings":"","what":"Time Expectations & Critical Warnings","title":"TreeDist R Package Development","text":"R startup: ~0.1 seconds Linting: 1-3 minutes full codebase Quick check (vignettes/manual): 2-5 minutes Documentation building: 2-5 minutes Test suite: 10-30+ minutes (NEVER CANCEL - set 60+ minute timeout) Full R CMD check: 15-45+ minutes (NEVER CANCEL - set 90+ minute timeout) Package build: 10-30+ minutes (NEVER CANCEL - set 60+ minute timeout) Vignette building: 5-15+ minutes (NEVER CANCEL - set 30+ minute timeout) Benchmarks: 5-20+ minutes (NEVER CANCEL - set 30+ minute timeout)","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"key-directories","dir":"","previous_headings":"Repository Structure","what":"Key Directories","title":"TreeDist R Package Development","text":"R/ - R source code (59 R files 500+ exported functions) src/ - C++ source code requiring compilation (17 C++ files, SystemRequirements: C++17) tests/testthat/ - Test suite (61+ test files) benchmark/ - Performance benchmarking (10+ benchmark files) man/ - Generated documentation (edit manually) vignettes/ - Package tutorials documentation data/ - Package data files .github/workflows/ - Extensive CI/CD R-CMD-check, benchmarks, memory checks","code":""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"important-files","dir":"","previous_headings":"Repository Structure","what":"Important Files","title":"TreeDist R Package Development","text":"DESCRIPTION - Package metadata, dependencies, system requirements NAMESPACE - Generated roxygen2 (edit manually) .lintr - Code style configuration (follows Google R style guide) NEWS.md - Version history (update user-facing changes) tests/testthat.R - Test runner entry point","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"after-making-changes","dir":"","previous_headings":"Common Tasks","what":"After Making Changes","title":"TreeDist R Package Development","text":"Load test changes interactively: Run linting: Run relevant tests: C++ changes, always run full check:","code":"R -e \"devtools::load_all(); # test your changes interactively\" R -e \"lintr::lint_dir('.')\" R -e \"devtools::test()\" R CMD check --no-build-vignettes ."},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"code-style-guidelines","dir":"","previous_headings":"Common Tasks","what":"Code Style Guidelines","title":"TreeDist R Package Development","text":"Follow Google’s R style guide Use camelCase variable names, TitleCase function names Use Oxford ending ‘ize’ (‘ise’) UK spelling applicable Document functions roxygen2 comments Include test cases new functionality","code":""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"ci-will-fail-if","dir":"","previous_headings":"Common Tasks","what":"CI Will Fail If","title":"TreeDist R Package Development","text":"R CMD check fails Tests fail Code style violations (lintr) Missing inadequate documentation Missing test coverage new code","code":""},{"path":"https://ms609.github.io/TreeDist/dev/copilot-instructions.html","id":"troubleshooting","dir":"","previous_headings":"","what":"Troubleshooting","title":"TreeDist R Package Development","text":"package won’t build: check system dependencies installed tests fail C++ changes: rebuild package completely documentation missing: run devtools::document() benchmarks fail: performance regressions may need investigation Memory issues: use valgrind checking C++ code validation","code":""},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"treedist","dir":"","previous_headings":"","what":"Calculate and Map Distances Between Phylogenetic Trees","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"‘TreeDist’ R package implements suite metrics quantify topological distance pairs unweighted phylogenetic trees. also includes simple ‘Shiny’ application allow visualization distance-based tree spaces, functions calculate information content trees splits. ‘TreeDist’ primarily employs metrics category ‘generalized Robinson–Foulds distances’: based comparing splits (bipartitions) trees, thus reflect relationship data within trees, reference branch lengths.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"generalized-rf-distances","dir":"","previous_headings":"","what":"Generalized RF distances","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"Robinson-Foulds distance simply tallies number non-trivial splits (sometimes inaccurately termed clades, nodes edges) occur trees – splits perfectly identical contribute one point distance score zero, however similar different . overlooking potential similarities almost-identical splits, conservative approach undesirable properties. ‘Generalized’ RF metrics generate matchings pair splits one tree similar splits . pair splits assigned similarity score; sum scores optimal matching quantifies similarity two trees. Different ways calculating similarity pair splits lead different tree distance metrics, implemented functions : MutualClusteringInfo(), SharedPhylogeneticInfo() Smith (2020) scores matchings based amount information one partition contains . Mutual Phylogenetic Information assigns zero similarity split pairs exist single tree; Mutual Clustering Information metric forgiving, exhibits desirable behaviour; recommended metric tree comparison. (complement, ClusteringInfoDistance(), returns tree distance.)  NyeSimilarity() Nye et al. (2006) score matchings according size largest split consistent , normalized Jaccard index. approach extended Böcker et al. (2013) Jaccard-Robinson-Foulds metric (function JaccardRobinsonFoulds()). MatchingSplitDistance() Bogdanowicz Giaro (2012) Lin et al. (2012) independently proposed counting number ‘mismatched’ leaves pair splits. MatchingSplitInfoDistance() provides information-based equivalent (Smith 2020). package also implements variation path distance proposed Kendal Colijn (2016) (function KendallColijn()), approximations Nearest-Neighbour Interchange (NNI) distance (function NNIDist(); following Li et al. (1996)), calculates size (function MASTSize()) information content (function MASTInfo()) Maximum Agreement Subtree. implementation Tree Bisection Reconnection (TBR) distance, see package ‘TBRDist’.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"Install load library CRAN follows: can install development version package :","code":"install.packages('TreeDist') library('TreeDist') if(!require(\"curl\")) install.packages(\"curl\") if(!require(\"remotes\")) install.packages(\"remotes\") remotes::install_github(\"ms609/TreeDist\")"},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"tree-space-analysis","dir":"","previous_headings":"","what":"Tree space analysis","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"Construct tree spaces readily visualize projected landscapes, avoiding common analytical pitfalls (Smith, 2022), using inbuilt graphical user interface (Shiny GUI): Serious analysts consult vignette command-line interface.","code":"TreeDist::MapTrees()"},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"Using ‘TreeDist’ Package functions Tree spaces ‘TreeDist’ vignettes","code":""},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"see-also","dir":"","previous_headings":"","what":"See also","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"R packages implementing tree distance functions include: cophenetic.phylo(): Cophenetic distance dist.topo(): Path (topological) distance, Robinson-Foulds distance. treedist(): Path, Robinson-Foulds approximate SPR distances. ‘Quartet’: Triplet Quartet distances, using tqDist algorithm. ‘TBRDist’: TBR SPR distances unrooted trees, using ‘uspr’ C library. ‘treespace’: Kendall-Colijn distance tree space visualizations. ‘distory’ (unmaintained): Geodesic distance","code":""},{"path":"https://ms609.github.io/TreeDist/dev/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Calculate and Map Distances Between Phylogenetic Trees","text":"Böcker, S. et al. (2013) Generalized Robinson-Foulds metric. Algorithms Bioinformatics. WABI 2013. Lecture Notes Computer Science, 8126, 156–69. Bogdanowicz, D. Giaro, K. (2012) Matching split distance unrooted binary phylogenetic trees. IEEE/ACM Transactions Computational Biology Bioinformatics, 9, 150–160. Kendall, M. Colijn, C. (2016) Mapping phylogenetic trees reveal distinct patterns evolution. Mol Biol Evol, 33, 2735–2743. Li, M., Tromp, J. Zhang, L.-X. (1996) notes nearest neighbour interchange distance. Computing Combinatorics, Goos, G., Hartmanis, J., Leeuwen, J., Cai, J.-Y., Wong, C. K., eds. Springer, Berlin. 343–351. Nye, T.M.W. et al. (2006) novel algorithm web-based tool comparing two alternative phylogenetic trees. Bioinformatics, 22, 117–119. Smith, M.R. (2020) Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees. Bioinformatics, 36, 5007–5013. Smith, M.R. (2022) Robust analysis phylogenetic tree space. Systematic Biology, 71, 1255–1270. Please note ‘TreeDist’ project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":null,"dir":"Reference","previous_headings":"","what":"Variation of information for all split pairings — AllSplitPairings","title":"Variation of information for all split pairings — AllSplitPairings","text":"Calculate variation clustering information (Meila 2007)  possible pairing non-trivial splits n leaves (Smith 2020) , tabulating number pairings similarity.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variation of information for all split pairings — AllSplitPairings","text":"","code":"AllSplitPairings(n)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variation of information for all split pairings — AllSplitPairings","text":"n Integer specifying number leaves tree.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variation of information for all split pairings — AllSplitPairings","text":"AllSplitPairings() returns named vector. name element corresponds certain variation information, bits; value element specifies number pairings non-trivial splits give rise variation information. Split AB|CD  treated distinct CD|AB.  pairing AB|CD=CD|AB considered equivalent CD|AB=CD|AB (etc), values divided four.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Variation of information for all split pairings — AllSplitPairings","text":"Meila M (2007). “Comparing clusterings—information based distance.” Journal Multivariate Analysis, 98(5), 873–895. doi:10.1016/j.jmva.2006.11.013 . Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Variation of information for all split pairings — AllSplitPairings","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/AllSplitPairings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variation of information for all split pairings — AllSplitPairings","text":"","code":"AllSplitPairings(6) #>                0                1 1.33333333333333 1.74837083261218  #>              100              480              360              480  #> 1.83659166810898 1.91829583405449  #>              360              720  # Treat equivalent splits as identical by dividing by four: AllSplitPairings(6) / 4L #>                0                1 1.33333333333333 1.74837083261218  #>               25              120               90              120  #> 1.83659166810898 1.91829583405449  #>               90              180"},{"path":"https://ms609.github.io/TreeDist/dev/reference/CalculateTreeDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper for tree distance calculations — CalculateTreeDistance","title":"Wrapper for tree distance calculations — CalculateTreeDistance","text":"Calls tree distance functions trees lists trees","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CalculateTreeDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper for tree distance calculations — CalculateTreeDistance","text":"","code":"CalculateTreeDistance(Func, tree1, tree2 = NULL, reportMatching = FALSE, ...)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/CalculateTreeDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper for tree distance calculations — CalculateTreeDistance","text":"Func Tree distance function. tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . reportMatching Logical specifying whether return clade matchings attribute score. ... Additional arguments Func.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CalculateTreeDistance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wrapper for tree distance calculations — CalculateTreeDistance","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances between each pair of trees — CompareAll","title":"Distances between each pair of trees — CompareAll","text":"Calculate distance tree list, tree list.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distances between each pair of trees — CompareAll","text":"","code":"CompareAll(x, Func, FUN.VALUE = Func(x[[1]], x[[1]], ...), ...)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distances between each pair of trees — CompareAll","text":"x List trees, format expected Func(). Func distance function returning distance two trees, e.g. path.dist(). FUN.VALUE Format output Func(), passed vapply(). unspecified, calculated running Func(x[[1]], x[[1]]). ... Additional parameters pass Func().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distances between each pair of trees — CompareAll","text":"CompareAll() returns distance matrix class dist detailing distance pair trees. Identical trees assumed zero distance.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distances between each pair of trees — CompareAll","text":"CompareAll() limited tree comparisons: Func can symmetric function.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distances between each pair of trees — CompareAll","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/CompareAll.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distances between each pair of trees — CompareAll","text":"","code":"# Generate a list of trees to compare library(\"TreeTools\", quietly = TRUE) trees <- list(bal1 = BalancedTree(1:8),                pec1 = PectinateTree(1:8),               pec2 = PectinateTree(c(4:1, 5:8)))  # Compare each tree with each other tree CompareAll(trees, NNIDist) #> $lower #>      bal1 pec1 pec2 #> bal1         2    2 #> pec1    2         2 #> pec2    2    2      #>  #> $best_lower #>      bal1 pec1 pec2 #> bal1         2    2 #> pec1    2         3 #> pec2    2    3      #>  #> $tight_upper #>      bal1 pec1 pec2 #> bal1         2    2 #> pec1    2         3 #> pec2    2    3      #>  #> $best_upper #>      bal1 pec1 pec2 #> bal1         2    2 #> pec1    2         3 #> pec2    2    3      #>  #> $loose_upper #>      bal1 pec1 pec2 #> bal1         4    4 #> pec1    4         5 #> pec2    4    5      #>  #> $fack_upper #>      bal1 pec1 pec2 #> bal1         4    4 #> pec1    4         5 #> pec2    4    5      #>  #> $li_upper #>      bal1 pec1 pec2 #> bal1        10   10 #> pec1   10         8 #> pec2   10    8      #>     # Providing FUN.VALUE yields a modest speed gain: dist <- CompareAll(trees, NNIDist, FUN.VALUE = integer(7))    # View distances as a matrix as.matrix(dist$lower) #>      bal1 pec1 pec2 #> bal1    0    2    2 #> pec1    2    0    2 #> pec2    2    2    0"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":null,"dir":"Reference","previous_headings":"","what":"Entropy in bits — Entropy","title":"Entropy in bits — Entropy","text":"Calculate entropy vector probabilities, bits. Probabilities sum one. Probabilities equalling zero ignored.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Entropy in bits — Entropy","text":"","code":"Entropy(...)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Entropy in bits — Entropy","text":"... Numerics numeric vector specifying probabilities outcomes.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Entropy in bits — Entropy","text":"Entropy() returns entropy specified probabilities, bits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Entropy in bits — Entropy","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Entropy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Entropy in bits — Entropy","text":"","code":"Entropy(1/2, 0, 1/2) # = 1 #> [1] 1 Entropy(rep(1/4, 4)) # = 2 #> [1] 2"},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Robinson–Foulds distance — GeneralizedRF","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"internal function calculate Generalized Robinson–Foulds distances splits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"","code":"GeneralizedRF(   splits1,   splits2,   nTip,   PairScorer,   maximize,   reportMatching,   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip Integer specifying number leaves split. PairScorer function taking four arguments, splits1, splits2, nSplits1, nSplits2, return score pair splits two-dimensional matrix.  Additional parameters may specified via .... reportMatching Logical specifying whether return clade matchings attribute score. ... Additional parameters PairScorer","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"numeric value specifying score tree pairs specified pair scorer. reportMatching = TRUE, attribute also list: matching: split splits2 optimally matched split split1 (NA matched); matchedSplits: Textual representation match matchedScores: Scores matched split. pairScores: Calculated scores possible matching split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"Note checks made confirm splits1 splits2 contain leaves order. responsibility calling function.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/GeneralizedRF.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized Robinson–Foulds distance — GeneralizedRF","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":null,"dir":"Reference","previous_headings":"","what":"Find islands from distance matrix — Islands","title":"Find islands from distance matrix — Islands","text":"Islands() assigns set objects islands, elements within island can form connected graph edge longer threshold distance units Silva , Wilkinson M (2021). “Defining Finding Islands Trees Mitigating Large Island Bias.” Systematic Biology, 70(6), 1282–1294. doi:10.1093/sysbio/syab015 . .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find islands from distance matrix — Islands","text":"","code":"Islands(D, threshold, dense = TRUE, smallest = 0)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find islands from distance matrix — Islands","text":"D Square matrix dist object containing Euclidean distances data points. threshold Elements greater threshold distance units assigned island. dense Logical; FALSE, island named according index lowest-indexed member; TRUE, island numbered sequentially 1, ordered index lowest-indexed member. smallest Integer; Islands comprising smallest elements assigned island NA.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find islands from distance matrix — Islands","text":"Islands() returns vector listing island element assigned.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find islands from distance matrix — Islands","text":"references Rd macro \\insertAllCites help page.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find islands from distance matrix — Islands","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Islands.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find islands from distance matrix — Islands","text":"","code":"library(\"TreeTools\", quietly = TRUE) # Generate a set of trees trees <- as.phylo(as.TreeNumber(BalancedTree(16)) + c(-(40:20), 70:105), 16)  # Calculate distances between trees distances <- ClusteringInfoDist(trees) summary(distances) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.8997  2.8945  4.5822  4.3967  6.1634  7.0885   # Assign trees to islands isle <- Islands(distances, quantile(distances, 0.1)) table(isle) #> isle #>  1  2  3  #> 12  9 36   # Indicate island membership on 2D mapping of tree distances mapping <- cmdscale(distances, 2) plot(mapping, col = isle + 1,      asp = 1, # Preserve aspect ratio - do not distort distances      ann = FALSE, axes = FALSE, # Don't label axes: dimensions are meaningless)      pch = 16 # Plotting character: Filled circle )   # Compare strict consensus with island consensus trees oPar <- par(mfrow = c(2, 2), mai = rep(0.1, 4)) plot(Consensus(trees), main = \"Strict\") plot(Consensus(trees[isle == 1]), edge.col = 2, main = \"Island 1\") plot(Consensus(trees[isle == 2]), edge.col = 3, main = \"Island 2\") plot(Consensus(trees[isle == 3]), edge.col = 4, main = \"Island 3\")   # Restore graphical parameters par(oPar)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":null,"dir":"Reference","previous_headings":"","what":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"Calculate Jaccard–Robinson–Foulds metric (Böcker et al. 2013) , Generalized Robinson–Foulds metric.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"","code":"JaccardRobinsonFoulds(   tree1,   tree2 = NULL,   k = 1L,   allowConflict = TRUE,   similarity = FALSE,   normalize = FALSE,   reportMatching = FALSE )  JaccardSplitSimilarity(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   k = 1L,   allowConflict = TRUE,   reportMatching = FALSE )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . k arbitrary exponent raise Jaccard index. Integer values greater one anticipated Böcker et al. Nye et al. metric uses k = 1. k increases towards infinity, metric converges Robinson–Foulds metric. allowConflict Logical specifying whether allow conflicting splits paired. FALSE, pairings allocated similarity score zero. similarity Logical specifying whether report result tree similarity, rather difference. normalize numeric value provided, used maximum value rescale results. TRUE, results rescaled maximum value calculated specified tree sizes topology, specified \"Normalization\" section . FALSE, results rescaled. reportMatching Logical specifying whether return clade matchings attribute score. splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip (Optional) Integer specifying number leaves split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"JaccardRobinsonFoulds() returns array numerics providing distances  pair trees tree1 tree2, splits1 splits2.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"short, Jaccard–Robinson–Foulds metric generalized Robinson-Foulds metric: finds optimal matching pairs split one tree similar split second. Matchings scored according size largest split consistent , normalized Jaccard index, raised arbitrary exponent. detailed explanation provided vignettes. default, conflicting splits may paired. Note settings k = 1, allowConflict = TRUE, similarity = TRUE give similarity metric Nye et al. (2006) ; slightly faster implementation metric available NyeSimilarity(). examples section details visualize matchings non-default parameter values. Trees need contain identical leaves; scores based leaves trees hold common.  Check unexpected differences tip labelling setdiff(TipLabels(tree1), TipLabels(tree2)).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"normalization","dir":"Reference","previous_headings":"","what":"Normalization","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"normalize = TRUE, results rescaled zero one dividing maximum possible value trees given topologies, equal sum number splits tree. may wish normalize instead maximum number splits present pair trees n leaves, specifying normalize = n - 3.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"Böcker S, Canzar S, Klau GW (2013). “generalized Robinson-Foulds metric.” Darling , Stoye J (eds.), Algorithms Bioinformatics. WABI 2013. Lecture Notes Computer Science, vol 8126, 156–169. Springer, Berlin, Heidelberg. doi:10.1007/978-3-642-40453-5_13 . Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Nye TMW, Liò P, Gilks WR (2006). “novel algorithm web-based tool comparing two alternative phylogenetic trees.” Bioinformatics, 22(1), 117–119. doi:10.1093/bioinformatics/bti720 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/JaccardRobinsonFoulds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jaccard–Robinson–Foulds metric — JaccardRobinsonFoulds","text":"","code":"set.seed(2) tree1 <- ape::rtree(10) tree2 <- ape::rtree(10) JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = FALSE) #> [1] 12.0105 JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = TRUE) #> [1] 11.40222  JRF2 <- function(tree1, tree2, ...)    JaccardRobinsonFoulds(tree1, tree2, k = 2, allowConflict = FALSE, ...)    VisualizeMatching(JRF2, tree1, tree2, matchZeros = FALSE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":null,"dir":"Reference","previous_headings":"","what":"k-means++ clustering — KMeansPP","title":"k-means++ clustering — KMeansPP","text":"k-means++ clustering (Arthur Vassilvitskii 2007)  improves speed accuracy standard kmeans clustering (Hartigan Wong 1979)  preferring initial cluster centres far others. scalable version algorithm proposed larger data sets (Bahmani et al. 2012) , implemented .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"k-means++ clustering — KMeansPP","text":"","code":"KMeansPP(x, k = 2, nstart = 10, ...)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"k-means++ clustering — KMeansPP","text":"x Numeric matrix data, object can coerced matrix (numeric vector data frame numeric columns). k Integer specifying number clusters, k. nstart Positive integer specifying many random sets chosen ... additional arguments passed kmeans","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"k-means++ clustering — KMeansPP","text":"Arthur D, Vassilvitskii S (2007). “K-Means++: Advantages Careful Seeding.” Proceedings Eighteenth Annual ACM-SIAM Symposium Discrete Algorithms,  SODA '07, 1027–1035. Bahmani B, Moseley B, Vattani , Kumar R, Vassilvitskii S (2012). “Scalable K-Means++.” arXiv. doi:10.48550/arXiv.1203.6402 , 1203.6402. Hartigan JA, Wong MA (1979). “Algorithm 136: K-means clustering algorithm.” Journal Royal Statistical Society. Series C (Applied Statistics), 28(1), 100–108. doi:10.2307/2346830 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"k-means++ clustering — KMeansPP","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KMeansPP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"k-means++ clustering — KMeansPP","text":"","code":"# Generate random points set.seed(1) x <- cbind(c(rnorm(10, -5), rnorm(5, 1), rnorm(10, 6)),            c(rnorm(5, 0), rnorm(15, 4), rnorm(5, 0)))  # Conventional k-means may perform poorly klusters <- kmeans(x, cent = 5) plot(x, col = klusters$cluster, pch = rep(15:19, each = 5))   # Here, k-means++ recovers a better clustering plusters <- KMeansPP(x, k = 5) plot(x, col = plusters$cluster, pch = rep(15:19, each = 5))"},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":null,"dir":"Reference","previous_headings":"","what":"Kendall–Colijn distance — KendallColijn","title":"Kendall–Colijn distance — KendallColijn","text":"Calculate Kendall–Colijn tree distance, measure related path difference.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kendall–Colijn distance — KendallColijn","text":"","code":"KendallColijn(tree1, tree2 = NULL, Vector = KCVector)  KCVector(tree)  PathVector(tree)  SplitVector(tree)  KCDiameter(tree)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kendall–Colijn distance — KendallColijn","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . Vector Function converting tree numeric vector. KCVector, default, returns number edges common ancestor pair leaves root tree (per Kendall Colijn 2016) . PathVector returns number edges pair leaves (per Steel Penny 1993) . SplitVector returns size smallest split contains pair leaves (per Smith 2022 ). tree tree class phylo.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kendall–Colijn distance — KendallColijn","text":"KendallColijn() returns array numerics providing distances  pair trees tree1 tree2, splits1 splits2. KCDiameter() returns value Kendall & Colijn's (2016) metric distance two pectinate trees n leaves ordered opposite direction, suggest (without attempt proof) may useful proxy diameter (.e. maximum value) K–C metric.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kendall–Colijn distance — KendallColijn","text":"Kendall–Colijn distance works measuring, pair leaves, distance recent common ancestor leaves root node. given tree, produces vector values recording distance---root recent common ancestor pair leaves. Two trees compared taking Euclidean distance respective vectors.  calculated taking square root sum squares differences vectors. analogous distance can created vector representation tree. split size vector metric (Smith 2022)  attempt mimic Kendall Colijn metric situations position root afforded special significance; path distance (Steel Penny 1993)  familiar alternative whose underlying vector measures distance last common ancestor pair leaves leaves , .e. length path one leaf another. None vector-based methods performs well tree distances measuring similarities relationships implied pair trees (Smith 2020) ; particular, Kendall Colijn metric strongly influenced tree balance, may appropriate suite common applications (Smith 2022) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Kendall–Colijn distance — KendallColijn","text":"KCVector(): Creates vector characterises rooted tree, described Kendall Colijn (2016) . PathVector(): Creates vector reporting number edges pair leaves, per path metric Steel Penny (1993) . SplitVector(): Creates vector reporting smallest split containing pair leaves, per metric proposed Smith (2022) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kendall–Colijn distance — KendallColijn","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Kendall M, Colijn C (2016). “Mapping phylogenetic trees reveal distinct patterns evolution.” Molecular Biology Evolution, 33(10), 2735–2743. doi:10.1093/molbev/msw124 . Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 . Smith MR (2022). “Robust analysis phylogenetic tree space.” Systematic Biology, 71(5), 1255–1270. doi:10.1093/sysbio/syab100 . Steel MA, Penny D (1993). “Distributions tree comparison metrics—new results.” Systematic Biology, 42(2), 126–141. doi:10.1093/sysbio/42.2.126 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Kendall–Colijn distance — KendallColijn","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/KendallColijn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kendall–Colijn distance — KendallColijn","text":"","code":"KendallColijn(TreeTools::BalancedTree(8), TreeTools::PectinateTree(8)) #> [1] 11.48913  set.seed(0) KendallColijn(TreeTools::BalancedTree(8), lapply(rep(8, 3), ape::rtree)) #> [1] 9.591663 5.567764 9.949874 KendallColijn(lapply(rep(8, 4), ape::rtree)) #>          1        2        3 #> 2 7.280110                   #> 3 7.874008 8.185353          #> 4 4.795832 7.071068 7.681146  KendallColijn(lapply(rep(8, 4), ape::rtree), Vector = SplitVector) #>           1         2         3 #> 2 10.862780                     #> 3 10.148892 12.124356           #> 4  8.000000 11.489125  8.185353  # Notice that changing tree shape close to the root results in much # larger differences tree1 <- ape::read.tree(text = \"(a, (b, (c, (d, (e, (f, (g, h)))))));\") tree2 <- ape::read.tree(text = \"(a, ((b, c), (d, (e, (f, (g, h))))));\") tree3 <- ape::read.tree(text = \"(a, (b, (c, (d, (e, ((f, g), h))))));\") trees <- c(tree1, tree2, tree3) KendallColijn(trees) #>          1        2 #> 2 4.000000          #> 3 1.414214 4.242641 KendallColijn(trees, Vector = SplitVector) #>          1        2 #> 2 2.449490          #> 3 2.449490 3.162278 KCDiameter(4) #> [1] 3.162278 KCDiameter(trees) #> [1] 15.87451 15.87451 15.87451"},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve linear assignment problem using LAPJV — LAPJV","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"Use algorithm Jonker Volgenant (1987)  solve Linear Sum Assignment Problem (LSAP).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"","code":"LAPJV(x)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"x Matrix costs.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"LAPJV() returns list two entries: score, score optimal matching; matching, columns matched row matrix turn.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"Linear Assignment Problem seeks match row matrix column, cost matching minimized. Jonker & Volgenant approach faster alternative Hungarian algorithm (Munkres 1957) , implemented clue::solve_LSAP(). Note: JV algorithm expects integers. order apply function non-integer n, tree distance calculations package, n multiplied largest available integer applying JV algorithm.  two values n exhibit trivial difference – e.g. due floating point errors – can lead interminable run times.  (numbers magnitude billions differ last significant digit, JV algorithm may undergo billions iterations.)  avoid , integers 2^22 differ value 8 less treated equal.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"Jonker R, Volgenant (1987). “shortest augmenting path algorithm dense sparse linear assignment problems.” Computing, 38, 325–340. doi:10.1007/BF02278710 . Munkres J (1957). “Algorithms assignment transportation problems.” Journal Society Industrial Applied Mathematics, 5(1), 32–38. doi:10.1137/0105003 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"C++ code Roy Jonker, MagicLogic Optimization Inc. roy_jonker@magiclogic.com, contributions Yong Yang yongyanglink@gmail.com, Yi Cao","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/LAPJV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve linear assignment problem using LAPJV — LAPJV","text":"","code":"problem <- matrix(c(7, 9, 8, 9, 9,                     2, 8, 5, 7, 9,                     1, 6, 6, 9, 9,                     3, 6, 2, 2, 9), 4, 5, byrow = TRUE)  LAPJV(problem) #> $score #> [1] 17 #>  #> $matching #> [1] 2 3 1 4 #>"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum Agreement Subtree size — MASTSize","title":"Maximum Agreement Subtree size — MASTSize","text":"Calculate size phylogenetic information content (Steel Penny 2006)  maximum agreement subtree two phylogenetic trees, .e. largest tree can obtained tree1 tree2 deleting, rearranging, leaves, using algorithm Valiente (2009) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum Agreement Subtree size — MASTSize","text":"","code":"MASTSize(tree1, tree2 = tree1, rooted = TRUE)  MASTInfo(tree1, tree2 = tree1, rooted = TRUE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum Agreement Subtree size — MASTSize","text":"tree1, tree2 Trees class phylo, lists trees undergo pairwise comparison. rooted Logical specifying whether treat trees rooted.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum Agreement Subtree size — MASTSize","text":"MASTSize() returns integer specifying number leaves maximum agreement subtree. MASTInfo() returns vector matrix listing phylogenetic information content, bits, maximum agreement subtree.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum Agreement Subtree size — MASTSize","text":"Implemented trees 4096 tips.  Contact maintainer need process larger trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Maximum Agreement Subtree size — MASTSize","text":"Steel MA, Penny D (2006). “Maximum parsimony phylogenetic information multistate characters.” Albert VA (ed.), Parsimony, Phylogeny, Genomics, 163–178. Oxford University Press, Oxford. Valiente G (2009). Combinatorial Pattern Matching Algorithms Computational Biology using Perl R,  CRC Mathematical Computing Biology Series. CRC Press, Boca Raton.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum Agreement Subtree size — MASTSize","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MASTSize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum Agreement Subtree size — MASTSize","text":"","code":"# for as.phylo, BalancedTree, PectinateTree: library(\"TreeTools\", quietly = TRUE)  MASTSize(PectinateTree(8), BalancedTree(8)) #> [1] 4 MASTInfo(PectinateTree(8), BalancedTree(8)) #> [1] 3.906891  MASTSize(BalancedTree(7), as.phylo(0:3, 7)) #> [1] 3 3 3 3 MASTSize(as.phylo(0:3, 7), PectinateTree(7)) #> [1] 6 5 5 5  MASTInfo(BalancedTree(7), as.phylo(0:3, 7)) #> [1] 1.584963 1.584963 1.584963 1.584963 MASTInfo(as.phylo(0:3, 7), PectinateTree(7)) #> [1] 9.884171 6.714246 6.714246 6.714246  MASTSize(list(Bal = BalancedTree(7), Pec = PectinateTree(7)),          as.phylo(0:3, 7)) #>     [,1] [,2] [,3] [,4] #> Bal    3    3    3    3 #> Pec    6    5    5    5 MASTInfo(list(Bal = BalancedTree(7), Pec = PectinateTree(7)),          as.phylo(0:3, 7)) #>         [,1]     [,2]     [,3]     [,4] #> Bal 1.584963 1.584963 1.584963 1.584963 #> Pec 9.884171 6.714246 6.714246 6.714246  CompareAll(as.phylo(0:4, 8), MASTSize) #>   1 2 3 4 5 #> 1   7 7 7 6 #> 2 7   7 6 7 #> 3 7 7   6 6 #> 4 7 6 6   7 #> 5 6 7 6 7   CompareAll(as.phylo(0:4, 8), MASTInfo) #>           1         2         3         4         5 #> 1           13.343602 13.343602 13.343602  9.884171 #> 2 13.343602           13.343602  9.884171 13.343602 #> 3 13.343602 13.343602            9.884171  9.884171 #> 4 13.343602  9.884171  9.884171           13.343602 #> 5  9.884171 13.343602  9.884171 13.343602"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":null,"dir":"Reference","previous_headings":"","what":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"identify strain multidimensional scaling distances, can useful plot minimum spanning tree (Gower 1966; Smith 2022) .  Colouring edge tree according strain can identify areas mapping stretched compressed.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"","code":"MSTSegments(mapping, mstEnds, ...)  StrainCol(   distances,   mapping,   mstEnds = MSTEdges(distances),   palette = rev(hcl.colors(256L, \"RdYlBu\")) )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"mapping Two-column matrix giving x y coordinates plotted points. mstEnds Two-column matrix identifying rows mapping end edge MST, output TreeTools::MSTEdges(). ... Additional arguments segments(). distances Matrix dist object giving original distances pair points. palette Vector colours colour edges.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"StrainCol() returns vector entry selected palette, attribute logStrain denoting logarithm mapped original distance, shifted median value zero. Palette colours assigned centred median value, entries early palette assigned edges ratio mapped distance original distance small.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"Gower JC (1966). “distance properties latent root vector methods used multivariate analysis.” Biometrika, 53(3/4), 325–338. doi:10.2307/2333639 . Smith MR (2022). “Robust analysis phylogenetic tree space.” Systematic Biology, 71(5), 1255–1270. doi:10.1093/sysbio/syab100 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MSTSegments.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add minimum spanning tree to plot, colouring by stress — MSTSegments","text":"","code":"set.seed(0) library(\"TreeTools\", quietly = TRUE) distances <- ClusteringInfoDist(as.phylo(5:16, 8)) mapping <- cmdscale(distances, k = 2) mstEnds <- MSTEdges(distances)  # Set up blank plot plot(mapping, asp = 1, frame.plot = FALSE, ann = FALSE, axes = FALSE,      type = \"n\") # Add MST MSTSegments(mapping, mstEnds,              col = StrainCol(distances, mapping, mstEnds)) # Add points at end so they overprint the MST points(mapping) PlotTools::SpectrumLegend(  \"bottomleft\",  legend = c(\"Extended\", \"Median\", \"Contracted\"),  bty = \"n\",     # No box  y.intersp = 2, # Expand in Y direction  palette = hcl.colors(256L, \"RdYlBu\", rev = TRUE) )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Graphical user interface for mapping distances and analysing tree space — MapTrees","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"MapTrees() launches \"Shiny\" application visualization evaluation tree spaces.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"","code":"MapTrees()  Project()"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"input-tab","dir":"Reference","previous_headings":"","what":"Input tab","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"input tab allows upload sets phylogenetic trees file. Trees start end file can excluded, number trees can brought manageable number uniformly subsampling every _n_th tree.  Samples c. 100 trees can analysed seconds; analysis larger samples take longer, particularly slower methods (e.g. quartet distances; Kruskal-1 MDS; large minimum spanning trees). Different batches can plotted different colours / symbols. tree associated property – example, data method used generate , stratigraphic congruence – list properties tree, one entry per line/row, can uploaded along trees.  Points tree space can styled according corresponding property. trees subsampled (using \"Sample every\" slider), values tree properties file can also subsampled accordingly. Unfortunately yet support multiple point property files; one file applied trees, sequence added memory.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"analysis-tab","dir":"Reference","previous_headings":"","what":"Analysis tab","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"Select suite distance methods: clustering information phylogenetic information quick satisfactory; quartet slow gives slightly better mappings; path fast may reflect evolutionary signal well; Robinson–Foulds probably never used analysis; included comparison purposes. Principle components mappings suffice purposes; Sammon Kruskal mappings slower seldom differ much, character quality, may emphasize outliers . Partitioning around medoids minimax-linkage hierarchical clustering typically find close--optimal clustering one exists; select additional methods exhaustive search. avoid redundant calculation, clusterings updated \"recalculate clustering\" clicked, \"maximum cluster number\" slider modified; clustering solutions using many clusters considered Clusterings silhouette coefficients < 0.25 unlikely represent genuine structure reported depicted.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"display-tab","dir":"Reference","previous_headings":"","what":"Display tab","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"15 dimensions can depicted; quality mapping – , faithfulness mapped distances true tree--tree distances – quantified product Trustworthiness Continuity metrics, exceed 0.9 (least). interactive 3D plot can explored dragging mouse scrolling, careful check three dimensions enough depict data accurately. minimum spanning tree shortest possible line selecting chosen subsample trees; takes convoluted zig-zagging route, mapping poor job reflecting true tree tree distances. Convex hulls smallest polygons enclosing points cluster; handy spotting clusters, area correspond genuine quantity, interpreted. Tree numbers correspond sequence trees original input file, subsampling. tree denoted point, whose symbol can styled according cluster membership according file contains tree, click \"Add existing\" input tab constituting new batch new symbol. Points can coloured according category – cluster batch belong, custom data provided Point Property File input tab – continuously, either sequence added memory, according custom data.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"exporting-tree-spaces","dir":"Reference","previous_headings":"","what":"Exporting tree spaces","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"mapping can saved PDF PNG bitmap size selected.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"list references employed constructing tree space populated according methods used; appropriate cite briefly discuss studies publication using figures generated using application.  application can cited using Smith (2020, 2022)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"references-1","dir":"Reference","previous_headings":"","what":"References","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 . Smith MR (2022). “Robust analysis phylogenetic tree space.” Systematic Biology, 71(5), 1255–1270. doi:10.1093/sysbio/syab100 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/MapTrees.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Graphical user interface for mapping distances and analysing tree space — MapTrees","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":null,"dir":"Reference","previous_headings":"","what":"Faithfulness of mapped distances — MappingQuality","title":"Faithfulness of mapped distances — MappingQuality","text":"MappingQuality() calculates trustworthiness continuity mapped distances (Venna Kaski 2001; Kaski et al. 2003) . Trustworthiness measures, scale 0–1, degree points nearby mapping truly close neighbours; continuity, extent points truly nearby retain close spatial proximity mapping.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Faithfulness of mapped distances — MappingQuality","text":"","code":"MappingQuality(original, mapped, neighbours = 10L)  ProjectionQuality(original, mapped, neighbours = 10L)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Faithfulness of mapped distances — MappingQuality","text":"original, mapped Square matrix dist object containing original / mapped pairwise distances. neighbours Integer specifying number nearest neighbours use calculation.  typically small relative number points.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Faithfulness of mapped distances — MappingQuality","text":"MappingQuality() returns named vector length four, containing entries: Trustworthiness, Continuity, TxC (product values), sqrtTxC (square root).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Faithfulness of mapped distances — MappingQuality","text":"Kaski S, Nikkila J, Oja M, Venna J, Toronen P, Castren E (2003). “Trustworthiness metrics visualizing similarity gene expression.” BMC Bioinformatics, 4, 48. doi:10.1186/1471-2105-4-48 . Venna J, Kaski S (2001). “Neighborhood preservation nonlinear projection methods: experimental study.” Dorffner G, Bischof H, Hornik K (eds.), Artificial Neural Networks — ICANN 2001,  Lecture Notes Computer Science, 485–491. doi:10.1007/3-540-44668-0_68 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Faithfulness of mapped distances — MappingQuality","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MappingQuality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Faithfulness of mapped distances — MappingQuality","text":"","code":"library(\"TreeTools\", quietly = TRUE) trees <- as.phylo(0:10, nTip = 8) distances <- ClusteringInfoDistance(trees) mapping <- cmdscale(distances) MappingQuality(distances, dist(mapping), 4) #> Trustworthiness      Continuity             TxC         sqrtTxC  #>       0.7929293       0.8737374       0.6928120       0.8323533"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching Split Distance — MatchingSplitDistance","title":"Matching Split Distance — MatchingSplitDistance","text":"Calculate Matching Split Distance (Bogdanowicz Giaro 2012; Lin et al. 2012)  unrooted binary trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching Split Distance — MatchingSplitDistance","text":"","code":"MatchingSplitDistance(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE )  MatchingSplitDistanceSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   normalize = TRUE,   reportMatching = FALSE )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching Split Distance — MatchingSplitDistance","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . normalize numeric value provided, used maximum value rescale results. TRUE, results rescaled maximum value calculated specified tree sizes topology, specified \"Normalization\" section . FALSE, results rescaled. reportMatching Logical specifying whether return clade matchings attribute score. splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip (Optional) Integer specifying number leaves split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching Split Distance — MatchingSplitDistance","text":"MatchingSplitDistance() returns array numerics providing distances  pair trees tree1 tree2, splits1 splits2.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matching Split Distance — MatchingSplitDistance","text":"Trees need contain identical leaves; scores based leaves trees hold common.  Check unexpected differences tip labelling setdiff(TipLabels(tree1), TipLabels(tree2)).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"normalization","dir":"Reference","previous_headings":"","what":"Normalization","title":"Matching Split Distance — MatchingSplitDistance","text":"normalization value function must provided order return normalized value.  aware generalised formula, please let know creating GitHub issue can implemented.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matching Split Distance — MatchingSplitDistance","text":"Bogdanowicz D, Giaro K (2012). “Matching split distance unrooted binary phylogenetic trees.” IEEE/ACM Transactions Computational Biology Bioinformatics, 9(1), 150–160. doi:10.1109/TCBB.2011.48 . Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Lin Y, Rajan V, Moret BME (2012). “metric phylogenetic trees based matching.” IEEE/ACM Transactions Computational Biology Bioinformatics, 4(9), 1014–1022. doi:10.1109/TCBB.2011.157 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matching Split Distance — MatchingSplitDistance","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MatchingSplitDistance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matching Split Distance — MatchingSplitDistance","text":"","code":"MatchingSplitDistance(lapply(rep(8, 5), ape::rtree), normalize = 16) #>       1     2     3     4 #> 2 0.750                   #> 3 0.750 0.500             #> 4 0.625 0.625 0.875       #> 5 0.750 0.500 0.250 0.750  MatchingSplitDistance(TreeTools::BalancedTree(6),                       TreeTools::PectinateTree(6),                       reportMatching = TRUE) #> [1] 2 #> attr(,\"matching\") #> [1] 2 1 3 #> attr(,\"matchedSplits\") #> [1] \"t1 t2 t3 | t4 t5 t6 => t4 t5 t6 | t1 t2 t3\" #> [2] \"t1 t2 | t3 t4 t5 t6 => t3 t4 t5 t6 | t1 t2\" #> [3] \"t4 t5 | t1 t2 t3 t6 => t5 t6 | t1 t2 t3 t4\" #> attr(,\"matchedScores\") #> [1] 0 0 2 #> attr(,\"pairScores\") #>      [,1] [,2] [,3] #> [1,]    1    0    1 #> [2,]    0    1    2 #> [3,]    2    1    2  VisualizeMatching(MatchingSplitDistance, TreeTools::BalancedTree(6),                   TreeTools::PectinateTree(6))"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"Compare pair splits viewed clusterings taxa, using variation clustering information proposed (Meila 2007) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"","code":"MeilaVariationOfInformation(split1, split2)  MeilaMutualInformation(split1, split2)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"split1, split2 Logical vectors listing leaves consistent order, identifying leaf member ingroup (TRUE) outgroup (FALSE) split question.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"MeilaVariationOfInformation() returns variation (clustering) information, measured bits. MeilaMutualInformation() returns mutual information, measured bits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"equivalent mutual clustering information (Vinh et al. 2010) . total information content, multiply VoI number leaves.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"Meila M (2007). “Comparing clusterings—information based distance.” Journal Multivariate Analysis, 98(5), 873–895. doi:10.1016/j.jmva.2006.11.013 . Vinh NX, Epps J, Bailey J (2010). “Information theoretic measures clusterings comparison: variants, properties, normalization correction chance.” Journal Machine Learning Research, 11, 2837–2854. doi:10.1145/1553374.1553511 .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/MeilaVariationOfInformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use variation of clustering information to compare pairs of splits — MeilaVariationOfInformation","text":"","code":"# Maximum variation = information content of each split separately A <- TRUE B <- FALSE MeilaVariationOfInformation(c(A, A, A, B, B, B), c(A, A, A, A, A, A)) #> [1] 1 Entropy(c(3, 3) / 6) + Entropy(c(0, 6) / 6) #> [1] 1  # Minimum variation = 0 MeilaVariationOfInformation(c(A, A, A, B, B, B), c(A, A, A, B, B, B)) #> [1] 0  # Not always possible for two evenly-sized splits to reach maximum # variation of information Entropy(c(3, 3) / 6) * 2  # = 2 #> [1] 2 MeilaVariationOfInformation(c(A, A, A,B ,B, B), c(A, B, A, B, A, B)) # < 2 #> [1] 1.836592  # Phylogenetically uninformative groupings contain spliting information Entropy(c(1, 5) / 6) #> [1] 0.6500224 MeilaVariationOfInformation(c(B, A, A, A, A, A), c(A, A, A, A, A, B)) #> [1] 1.203213"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate Nearest Neighbour Interchange distance — NNIDist","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"Use approach Li et al. (1996)  approximate Nearest Neighbour Interchange distance (Robinson 1971)  phylogenetic trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"","code":"NNIDist(tree1, tree2 = tree1)  NNIDiameter(tree)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"tree1, tree2 Single trees class phylo undergo comparison. tree Object supported class representing tree list trees, integer specifying number leaves tree/trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"NNIDist() returns, pair trees, named vector containing three integers: lower lower bound NNI distance, corresponds RF distance trees. tight_upper upper bound distance, based calculated maximum diameters trees < 13 leaves.  NA returned trees different employ approach. loose_upper looser upper bound distance, using n log n + O(n). NNIDiameter() returns matrix specifying (bounds ) diameter NNI distance metric specified tree(s). Columns correspond : liMin:  $$n - 3$$, lower bound diameter (Li et al. 1996); fackMin: Lower bound diameter following Fack et al. (2002), .e. $$\\log2{N!} / 4$$; min: larger liMin fackMin; exact: exact value diameter, n < 13; liMax: Upper bound diameter following Li et al. (1996), .e. $$n \\log2{n} + \\textrm{O}(n)$$; fackMax: Upper bound diameter following Fack et al. (2002), .e. ($$N - 2$$) ceiling($$\\log2{n}$$) N; max: smaller liMax fackMax; n number leaves, N number internal nodes, .e. $$n - 2$$.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"brief, approximation algorithm works identifying edges one tree match edges second.  edges must undergo least one NNI operation order reconcile trees. Edges match trees need never undergo NNI operation, divide tree smaller regions.  \"cutting\" matched edges two, tree can divided number regions solely comprise unmatched edges. regions can viewed separate trees need reconciled. One way reconcile trees conduct series NNI operations reduce tree pectinate (caterpillar) tree, conduct analogue mergesort algorithm.  takes n log n + O(n) NNI operations, provides loose upper bound NNI score. maximum number moves n-leaf tree (OEIS A182136) can calculated exactly small trees (Fack et al. 2002) ; provides tighter upper bound, unavailable n > 12. NNIDiameter() reports limits bound.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"Fack V, Lievens S, Van der Jeugt J (2002). “diameter rotation graph binary coupling trees.” Discrete Mathematics, 245(1-3), 1–18. doi:10.1016/S0012-365X(01)00418-6 . Li M, Tromp J, Zhang L (1996). “notes nearest neighbour interchange distance.” Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), Computing Combinatorics, volume 1090, 343–351. Springer, Berlin, Heidelberg. ISBN 978-3-540-61332-9 978-3-540-68461-9, doi:10.1007/3-540-61332-3_168 . Robinson DF (1971). “Comparison labeled trees valency three.” Journal Combinatorial Theory, Series B, 11(2), 105–119. doi:10.1016/0095-8956(71)90020-7 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NNIDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate Nearest Neighbour Interchange distance — NNIDist","text":"","code":"library(\"TreeTools\", quietly = TRUE)  NNIDist(BalancedTree(7), PectinateTree(7)) #>       lower  best_lower tight_upper  best_upper loose_upper  fack_upper  #>           2           2           2           2           4           4  #>    li_upper  #>          10   NNIDist(BalancedTree(7), as.phylo(0:2, 7)) #>             [,1] [,2] [,3] #> lower          4    3    4 #> best_lower     7    5    7 #> tight_upper    7    5    7 #> best_upper     7    5    7 #> loose_upper   14    8   14 #> fack_upper    14    8   14 #> li_upper      16   13   16 NNIDist(as.phylo(0:2, 7), PectinateTree(7)) #>             [,1] [,2] [,3] #> lower          4    4    4 #> best_lower     7    7    7 #> tight_upper    7    7    7 #> best_upper     7    7    7 #> loose_upper   14   14   14 #> fack_upper    14   14   14 #> li_upper      16   16   16  NNIDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),         as.phylo(0:2, 7)) #> , , lower #>  #>     [,1] [,2] [,3] #> bal    4    3    4 #> pec    4    4    4 #>  #> , , best_lower #>  #>     [,1] [,2] [,3] #> bal    7    5    7 #> pec    7    7    7 #>  #> , , tight_upper #>  #>     [,1] [,2] [,3] #> bal    7    5    7 #> pec    7    7    7 #>  #> , , best_upper #>  #>     [,1] [,2] [,3] #> bal    7    5    7 #> pec    7    7    7 #>  #> , , loose_upper #>  #>     [,1] [,2] [,3] #> bal   14    8   14 #> pec   14   14   14 #>  #> , , fack_upper #>  #>     [,1] [,2] [,3] #> bal   14    8   14 #> pec   14   14   14 #>  #> , , li_upper #>  #>     [,1] [,2] [,3] #> bal   16   13   16 #> pec   16   16   16 #>   CompareAll(as.phylo(30:33, 8), NNIDist) #> $lower #>   1 2 3 4 #> 1   1 1 2 #> 2 1   1 2 #> 3 1 1   2 #> 4 2 2 2   #>  #> $best_lower #>   1 2 3 4 #> 1   1 1 3 #> 2 1   1 3 #> 3 1 1   3 #> 4 3 3 3   #>  #> $tight_upper #>   1 2 3 4 #> 1   1 1 3 #> 2 1   1 3 #> 3 1 1   3 #> 4 3 3 3   #>  #> $best_upper #>   1 2 3 4 #> 1   1 1 3 #> 2 1   1 3 #> 3 1 1   3 #> 4 3 3 3   #>  #> $loose_upper #>   1 2 3 4 #> 1   2 2 5 #> 2 2   2 5 #> 3 2 2   5 #> 4 5 5 5   #>  #> $fack_upper #>   1 2 3 4 #> 1   2 2 5 #> 2 2   2 5 #> 3 2 2   5 #> 4 5 5 5   #>  #> $li_upper #>   1 2 3 4 #> 1   5 5 8 #> 2 5   5 8 #> 3 5 5   8 #> 4 8 8 8   #>"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize tree distances — NormalizeInfo","title":"Normalize tree distances — NormalizeInfo","text":"NormalizeInfo() internal function used normalize information reference, total information present pair trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize tree distances — NormalizeInfo","text":"","code":"NormalizeInfo(   unnormalized,   tree1,   tree2,   InfoInTree,   infoInBoth = NULL,   how = TRUE,   Combine = \"+\",   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize tree distances — NormalizeInfo","text":"unnormalized Numeric value, vector matrix normalized. tree1, tree2 Trees unnormalized calculated. InfoInTree Function calculate information content tree. infoInBoth Optional numeric specifying information content trees independently. unspecified (NULL), calculated using method specified . Method normalization, perhaps specified using normalize argument tree distance function.  See details options. ... Additional parameters InfoInTree() ().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize tree distances — NormalizeInfo","text":"NormalizeInfo() returns object corresponding normalized values unnormalized.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normalize tree distances — NormalizeInfo","text":"unnormalized value(s) normalized dividing denominator calculated based parameter.  Valid options include: FALSE normalization performed; unnormalized values returned. TRUE Unless infoInBoth specified, information tree computed using InfoInTree(), two values combined using Combine(). numeric value, vector matrix used denominator; returned value unnormalized / . function Unless infoInBoth specified, information tree computed using InfoInTree(), two values combined using .  NormalizeInfo(= Func) thus equivalent NormalizeInfo(= TRUE, Combine = Func).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Normalize tree distances — NormalizeInfo","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NormalizeInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize tree distances — NormalizeInfo","text":"","code":"library(\"TreeTools\", quietly = TRUE) pair1 <- c(BalancedTree(9), StarTree(9)) pair2 <- c(BalancedTree(9), PectinateTree(9))  # We'll let the number of nodes define the total information in a tree Nnode(pair1) #> [1] 8 1 Nnode(pair2) #> [1] 8 8  # Let's normalize a unit distance rawDist <- cbind(c(1, 1), c(1, 1))  # With `Combine = \"+\"`, the maximum distance is the sum of # the information in each tree denominator <- outer(Nnode(pair1), Nnode(pair2), \"+\")  NormalizeInfo(rawDist, pair1, pair2, InfoInTree = ape::Nnode, Combine = \"+\") #>           [,1]      [,2] #> [1,] 0.0625000 0.0625000 #> [2,] 0.1111111 0.1111111 rawDist / denominator #>           [,1]      [,2] #> [1,] 0.0625000 0.0625000 #> [2,] 0.1111111 0.1111111   # A denominator can be specified manually using `how`: NormalizeInfo(rawDist, pair1, pair2, InfoInTree = ape::Nnode, how = 16) #>        [,1]   [,2] #> [1,] 0.0625 0.0625 #> [2,] 0.0625 0.0625 rawDist / 16 #>        [,1]   [,2] #> [1,] 0.0625 0.0625 #> [2,] 0.0625 0.0625   # `how` also allows the denominator to be computed from trees: outer(Nnode(pair1), Nnode(pair2), pmin) #>      [,1] [,2] #> [1,]    8    8 #> [2,]    1    1 NormalizeInfo(rawDist, pair1, pair2, InfoInTree = ape::Nnode, how = pmin) #>       [,1]  [,2] #> [1,] 0.125 0.125 #> [2,] 1.000 1.000 rawDist / outer(Nnode(pair1), Nnode(pair2), pmin) #>       [,1]  [,2] #> [1,] 0.125 0.125 #> [2,] 1.000 1.000"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Nye et al. (2006) tree comparison — NyeSimilarity","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"NyeSimilarity() NyeSplitSimilarity() implement Generalized Robinson–Foulds tree comparison metric Nye et al. (2006) . short, finds optimal matching pairs branch one tree branch second, matchings scored according size largest split consistent , normalized Jaccard index. detailed account available vignettes.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"","code":"NyeSimilarity(   tree1,   tree2 = NULL,   similarity = TRUE,   normalize = FALSE,   normalizeMax = !is.logical(normalize),   reportMatching = FALSE,   diag = TRUE )  NyeSplitSimilarity(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . similarity Logical specifying whether report result tree similarity, rather difference. normalize numeric value provided, used maximum value rescale results. TRUE, results rescaled maximum value calculated specified tree sizes topology, specified \"Normalization\" section . FALSE, results rescaled. normalizeMax calculating similarity, normalize maximum number splits present (TRUE), number splits actually observed (FALSE)? Defaults number splits better-resolved tree; set normalize = pmin.int use number splits less resolved tree. reportMatching Logical specifying whether return clade matchings attribute score. diag Logical specifying whether return similarities along diagonal, .e. tree .  Applies tree2 list identical tree1, NULL. splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip (Optional) Integer specifying number leaves split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"NyeSimilarity() returns array numerics providing distances  pair trees tree1 tree2, splits1 splits2.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"measure defined similarity score.  similarity = FALSE, similarity score converted distance doubling subtracting number splits present trees. ensures consistency JaccardRobinsonFoulds. Note NyeSimilarity(tree1, tree2) equivalent , slightly faster , JaccardRobinsonFoulds (tree1, tree2, k = 1, allowConflict = TRUE).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"normalization","dir":"Reference","previous_headings":"","what":"Normalization","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"normalize = TRUE similarity = TRUE, results rescaled zero one dividing mean number splits two trees compared. may wish normalize instead number splits present smaller tree, represents maximum value possible pair trees specified topologies (normalize = pmin.int); number splits resolved tree (normalize = pmax.int); maximum value possible pair trees  n leaves, n - 3 (normalize = TreeTools::NTip(tree1) - 3L). normalize = TRUE similarity = FALSE, results rescaled zero one dividing total number splits pair trees considered. Trees need contain identical leaves; scores based leaves trees hold common.  Check unexpected differences tip labelling setdiff(TipLabels(tree1), TipLabels(tree2)).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Nye TMW, Liò P, Gilks WR (2006). “novel algorithm web-based tool comparing two alternative phylogenetic trees.” Bioinformatics, 22(1), 117–119. doi:10.1093/bioinformatics/bti720 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/NyeSimilarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nye et al. (2006) tree comparison — NyeSimilarity","text":"","code":"library(\"TreeTools\") NyeSimilarity(BalancedTree(8), PectinateTree(8)) #> [1] 3.8 VisualizeMatching(NyeSimilarity, BalancedTree(8), PectinateTree(8))  NyeSimilarity(as.phylo(0:5, nTip = 8), PectinateTree(8)) #> [1] 3.166667 2.750000 2.750000 2.500000 2.450000 2.500000 NyeSimilarity(as.phylo(0:5, nTip = 8), similarity = FALSE) #>          1        2        3        4        5 #> 2 1.333333                                     #> 3 1.333333 1.333333                            #> 4 2.166667 2.333333 2.333333                   #> 5 2.333333 2.166667 2.333333 1.000000          #> 6 2.000000 2.000000 1.500000 1.500000 1.500000"},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Path distance — PathDist","title":"Path distance — PathDist","text":"Calculate path distance rooted unrooted trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Path distance — PathDist","text":"","code":"PathDist(tree1, tree2 = NULL)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Path distance — PathDist","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Path distance — PathDist","text":"PathDist() returns vector distance matrix distances trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Path distance — PathDist","text":"function faster alternative function path.dist() phangorn package, can crash internal representation trees conform certain (unspecified) expectations, treats trees unrooted. path distance calculated tabulating cladistic difference (= topological distance) pair tips tree. precursor path distance (Farris 1969)  took mean squared difference elements tree's tabulation (Farris, 1973); method used proposed Steel Penny (1993) , takes square root sum. precursor measures described Williams Clifford (1971)  Phipps (1971) . root node present, trees treated rooted. avoid counting root edge twice, use UnrootTree(tree) calculating path distance. Use path distance discouraged emphasizes shallow relationships expense deeper (arguably fundamental) relationships (Farris 1973) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Path distance — PathDist","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Farris JS (1969). “successive approximations approach character weighting.” Systematic Biology, 18(4), 374–385. doi:10.2307/2412182 . Farris JS (1973). “comparing shapes taxonomic trees.” Systematic Zoology, 22(1), 50–54. doi:10.2307/2412378 . Phipps JB (1971). “Dendrogram topology.” Systematic Zoology, 20(3), 306. doi:10.2307/2412343 . Steel MA, Penny D (1993). “Distributions tree comparison metrics—new results.” Systematic Biology, 42(2), 126–141. doi:10.1093/sysbio/42.2.126 . Williams WT, Clifford HT (1971). “comparison two classifications set elements.” Taxon, 20(4), 519–522. doi:10.2307/1218253 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Path distance — PathDist","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/PathDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Path distance — PathDist","text":"","code":"library(\"TreeTools\")  # Treating the two edges to the root node as distinct PathDist(BalancedTree(7), PectinateTree(7)) #> [1] 5.656854  # Counting those two edges once PathDist(UnrootTree(BalancedTree(7)), UnrootTree(PectinateTree(7))) #> [1] 4.690416  PathDist(BalancedTree(7), as.phylo(0:2, 7)) #> [1] 8.944272 8.124038 8.944272 PathDist(as.phylo(0:2, 7), PectinateTree(7)) #> [1] 7.745967 8.246211 8.124038  PathDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),         as.phylo(0:2, 7)) #>          [,1]     [,2]     [,3] #> [1,] 8.944272 8.124038 8.944272 #> [2,] 7.745967 8.246211 8.124038  PathDist(as.phylo(30:33, 8)) #>          1        2        3 #> 2 3.872983                   #> 3 3.872983 3.464102          #> 4 5.567764 6.928203 6.928203"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Plot3.html","id":null,"dir":"Reference","previous_headings":"","what":"Pseudo-3D plotting — Plot3","title":"Pseudo-3D plotting — Plot3","text":"Plot3() displays three-dimensional data two dimensions, reflecting third dimension point scaling, overlap fogging. Points lower z value smaller , fainter , overlapped points higher value.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Plot3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pseudo-3D plotting — Plot3","text":"","code":"Plot3(   x,   y = NULL,   z = NULL,   pch = par(\"pch\"),   col = par(\"col\"),   bg = NA,   cex = 1,   axes = TRUE,   frame.plot = axes,   plot.bg = NA,   fog = 1/2,   shrink = 1/2,   add = FALSE,   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Plot3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pseudo-3D plotting — Plot3","text":"x, y, z Coordinates points plot. bg, cex, col, pch, add, axes, frame.plot, ... Parameters passed plot.default(). plot.bg Colour fill plot area, used fog colour. fog Numeric zero (fading) one (furthest points invisible) specifying amount fade distant points. shrink Numeric specifying degree size plotted point reflect z position. 0 denotes scaling; 1, furthest point zero size.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Plot3.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pseudo-3D plotting — Plot3","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Plot3.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pseudo-3D plotting — Plot3","text":"","code":"Plot3(1:10, 1:10, 1:10, cex = 7, pch = 16, axes = FALSE, asp = 1)  # Extreme values of fog and shrink will cause smallest z values to # become invisible. Plot3(1:10, 1:10, 1:10, cex = 7, pch = 16, axes = FALSE, asp = 1,       fog = 1, shrink = 1)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse areas of agreement between two trees — ReduceTrees","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"ReduceTrees() reduces trees according tree reduction rules Allen Steel (2001) : Collapse identical pendant subtrees; Compress equivalent internal chains.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"","code":"ReduceTrees(tree1, tree2, check = TRUE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"tree1, tree2 Single trees class phylo undergo comparison. check Logical specifying whether validate input. Specify FALSE encounter undefined behaviour trees binary phylo objects identical leaf labels, rooted leaf 1.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"ReduceTrees() returns list two trees, corresponding tree1 tree2 identical groupings collapsed, tree edges listed postorder; NULL trees equivalent.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReduceTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collapse areas of agreement between two trees — ReduceTrees","text":"","code":"tree1 <- TreeTools::BalancedTree(9) tree2 <- TreeTools::PectinateTree(9)  # Set graphical parameters oPar <- par(mai = rep(0.1, 4), mfrow = c(2, 2))  plot(tree1) plot(tree2)  # Reduce trees by collapsing identical clades confl <- ReduceTrees(tree1, tree2)  plot(confl[[1]]) plot(confl[[2]])   # Restore graphical parameters par(oPar)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReportMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"List clades as text — ReportMatching","title":"List clades as text — ReportMatching","text":"List clades text","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReportMatching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List clades as text — ReportMatching","text":"","code":"ReportMatching(splits1, splits2, realMatch = TRUE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReportMatching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List clades as text — ReportMatching","text":"splits1, splits2 Logical matrices columns specifying membership corresponding matched clade.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReportMatching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List clades as text — ReportMatching","text":"ReportMatching returns character vector describing pairing matching.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/ReportMatching.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"List clades as text — ReportMatching","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":null,"dir":"Reference","previous_headings":"","what":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"RobinsonFoulds() calculates Robinson–Foulds distance (Robinson Foulds 1981) , corresponding similarity measure. InfoRobinsonFoulds() weights splits according phylogenetic information content (§2.1 Smith 2020) . Optionally, matching identical splits may reported. Generalized Robinson–Foulds distances (see TreeDistance()) better suited use cases (Smith 2020, 2022) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"","code":"InfoRobinsonFoulds(   tree1,   tree2 = NULL,   similarity = FALSE,   normalize = FALSE,   reportMatching = FALSE )  InfoRobinsonFouldsSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )  RobinsonFoulds(   tree1,   tree2 = NULL,   similarity = FALSE,   normalize = FALSE,   reportMatching = FALSE )  RobinsonFouldsMatching(   tree1,   tree2,   similarity = FALSE,   normalize = FALSE,   ... )  RobinsonFouldsSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . similarity Logical specifying whether report result tree similarity, rather difference. normalize numeric value provided, used maximum value rescale results. TRUE, results rescaled maximum value calculated specified tree sizes topology, specified \"Normalization\" section . FALSE, results rescaled. reportMatching Logical specifying whether return clade matchings attribute score. splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip (Optional) Integer specifying number leaves split. ... used.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"RobinsonFoulds() InfoRobinsonFoulds() return array numerics providing distances  pair trees tree1 tree2, splits1 splits2. reportMatching = TRUE, pairScores attribute returns logical matrix specifying whether pair splits identical.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"RobinsonFoulds() calculates standard Robinson–Foulds distance, .e. number splits occur one tree . InfoRobinsonFoulds() calculates tree similarity distance summing phylogenetic information content splits () identical trees.  Consequently, splits likely identical chance alone make smaller contribution overall tree distance, similarity less remarkable. Rapid comparison multiple pairs trees employs Day (1985)  linear-time algorithm.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"RobinsonFouldsMatching(): Matched splits, intended use VisualizeMatching().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"normalization","dir":"Reference","previous_headings":"","what":"Normalization","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"RobinsonFoulds() normalized total number splits present. InfoRobinsonFoulds() normalized sum phylogenetic information splits tree, treated independently.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . Robinson DF, Foulds LR (1981). “Comparison phylogenetic trees.” Mathematical Biosciences, 53(1-2), 131–147. doi:10.1016/0025-5564(81)90043-2 . Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 . Smith MR (2022). “Robust analysis phylogenetic tree space.” Systematic Biology, 71(5), 1255–1270. doi:10.1093/sysbio/syab100 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/Robinson-Foulds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Robinson–Foulds distances, with adjustments for phylogenetic information content — Robinson-Foulds","text":"","code":"# For BalancedTree, PectinateTree, as.phylo: library(\"TreeTools\", quietly = TRUE) balanced7 <- BalancedTree(7) pectinate7 <- PectinateTree(7) RobinsonFoulds(balanced7, pectinate7) #> [1] 4 RobinsonFoulds(balanced7, pectinate7, normalize = TRUE) #> [1] 0.5 VisualizeMatching(RobinsonFouldsMatching, balanced7, pectinate7)   InfoRobinsonFoulds(balanced7, pectinate7) #> [1] 13.90209 VisualizeMatching(InfoRobinsonFoulds, balanced7, pectinate7)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"SPRDist() calculates upper bound SPR distance trees using heuristic method de Oliveira Martins et al. (2008) . approximations available (e.g. Hickey et al. 2008, Goloboff 2008, Whidden Matsen 2018) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"","code":"SPRDist(tree1, tree2 = NULL, method = \"deOliveira\", symmetric)  # S3 method for class 'phylo' SPRDist(tree1, tree2 = NULL, method = \"deOliveira\", symmetric)  # S3 method for class 'list' SPRDist(tree1, tree2 = NULL, method = \"deOliveira\", symmetric)  # S3 method for class 'multiPhylo' SPRDist(tree1, tree2 = NULL, method = \"deOliveira\", symmetric)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . method Character specifying method use approximate SPR distance.  Currently defaults \"deOliveira\", available option; new method eventually become default. symmetric Ignored (redundant fix phangorn#97).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"SPRDist() returns vector distance matrix distances trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . de Oliveira Martins L, Leal E, Kishino H (2008). “Phylogenetic detection recombination Bayesian prior distance trees.” PLoS One, 3(7), e2651. doi:10.1371/journal.pone.0002651 . Goloboff PA (2008). “Calculating SPR distances trees.” Cladistics, 24(4), 591-597. doi:10.1111/j.1096-0031.2007.00189.x . Hickey G, Dehne F, Rau-Chaplin , Blouin C (2008). “SPR distance computation unrooted trees.” Evolutionary Bioinformatics, 4, EBO–S419. doi:10.4137/EBO.S419 . Whidden C, Matsen FA (2018). “Efficiently Inferring Pairwise Subtree Prune--Regraft Adjacencies Phylogenetic Trees.” 2018 Proceedings Meeting Analytic Algorithmics Combinatorics (ANALCO), 77–91. doi:10.1137/1.9781611975062.8 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SPRDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate the Subtree Prune and Regraft (SPR) distance. — SPRDist","text":"","code":"library(\"TreeTools\", quietly = TRUE)  # Compare single pair of trees SPRDist(BalancedTree(7), PectinateTree(7)) #> [1] 2  # Compare all pairs of trees         SPRDist(as.phylo(30:33, 8)) #>   1 2 3 4 #> 1   1 1 1 #> 2 1   1 1 #> 3 1 1   1 #> 4 1 1 1    # Compare each tree in one list with each tree in another SPRDist(BalancedTree(7), as.phylo(0:2, 7)) #> [1] 2 2 2 SPRDist(as.phylo(0:2, 7), PectinateTree(7)) #> [1] 1 2 2  SPRDist(list(bal = BalancedTree(7), pec = PectinateTree(7)),         as.phylo(0:2, 7)) #>     [,1] [,2] [,3] #> bal    2    2    2 #> pec    1    2    2"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":null,"dir":"Reference","previous_headings":"","what":"Eigenvalues for spectral clustering — SpectralEigens","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"Spectral clustering emphasizes nearest neighbours forming clusters; avoids issues arise clustering around means / medoids.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"","code":"SpectralEigens(D, nn = 10L, nEig = 2L)  SpectralClustering(D, nn = 10L, nEig = 2L)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"D Square matrix dist object containing Euclidean distances data points. nn Integer specifying number nearest neighbours consider nEig Integer specifying number eigenvectors retain.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"SpectralEigens() returns spectral eigenvalues can clustered using method choice.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"Adapted MRS script Nura Kawa","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SpectralEigens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eigenvalues for spectral clustering — SpectralEigens","text":"","code":"library(\"TreeTools\", quietly = TRUE) trees <- as.phylo(0:18, nTip = 8) distances <- ClusteringInfoDistance(trees) eigens <- SpectralEigens(distances) # Perform clustering: clusts <- KMeansPP(dist(eigens), k = 3) plot(eigens, pch = 15, col = clusts$cluster)  plot(cmdscale(distances), pch = 15, col = clusts$cluster)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":null,"dir":"Reference","previous_headings":"","what":"Entropy of two splits — SplitEntropy","title":"Entropy of two splits — SplitEntropy","text":"Calculate entropy, joint entropy, entropy distance information content two splits, treating split division n leaves two groups. details available vignette, MacKay (2003)  Meila (2007) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Entropy of two splits — SplitEntropy","text":"","code":"SplitEntropy(split1, split2 = split1)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Entropy of two splits — SplitEntropy","text":"split1, split2 Logical vectors listing leaves consistent order, identifying leaf member ingroup (TRUE) outgroup (FALSE) split question.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Entropy of two splits — SplitEntropy","text":"numeric vector listing, bits: H1 entropy split 1; H2 entropy split 2; H12 joint entropy splits; mutual information splits; Hd entropy distance (variation information) splits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Entropy of two splits — SplitEntropy","text":"MacKay DJC (2003). Information Theory, Inference, Learning Algorithms. Cambridge University Press, Cambridge. https://www.inference.org.uk/itprnn/book.pdf. Meila M (2007). “Comparing clusterings—information based distance.” Journal Multivariate Analysis, 98(5), 873–895. doi:10.1016/j.jmva.2006.11.013 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Entropy of two splits — SplitEntropy","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitEntropy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Entropy of two splits — SplitEntropy","text":"","code":"A <- TRUE B <- FALSE SplitEntropy(c(A, A, A, B, B, B), c(A, A, B, B, B, B)) #>        H1        H2       H12         I        Hd  #> 1.0000000 0.9182958 1.4591479 0.4591479 1.0000000"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":null,"dir":"Reference","previous_headings":"","what":"Shared information content of two splits — SplitSharedInformation","title":"Shared information content of two splits — SplitSharedInformation","text":"Calculate phylogenetic information shared, shared, two splits. See accompanying vignette definitions.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shared information content of two splits — SplitSharedInformation","text":"","code":"SplitSharedInformation(n, A1, A2 = A1)  SplitDifferentInformation(n, A1, A2 = A1)  TreesConsistentWithTwoSplits(n, A1, A2 = A1)  LnTreesConsistentWithTwoSplits(n, A1, A2 = A1)  Log2TreesConsistentWithTwoSplits(n, A1, A2 = A1)  Log2TreesConsistentWithTwoSplits(n, A1, A2 = A1)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shared information content of two splits — SplitSharedInformation","text":"n Integer specifying number leaves A1, A2 Integers specifying number taxa A1 A2, splits arranged A1 fully overlaps A2.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shared information content of two splits — SplitSharedInformation","text":"TreesConsistentWithTwoSplits() returns number unrooted bifurcating trees consistent two splits. SplitSharedInformation() returns phylogenetic information two splits common (Meila 2007) , bits. SplitDifferentInformation() returns amount phylogenetic information distinct one two splits, bits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shared information content of two splits — SplitSharedInformation","text":"Split S1 divides n leaves two splits, A1 B1. Split S2 divides leaves splits A2 B2. Splits must named A1 fully overlaps A2: say, taxa A1 also A2, vice versa. Thus, taxa smaller A1 A2 also occur larger.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Shared information content of two splits — SplitSharedInformation","text":"SplitDifferentInformation(): Different information two splits. TreesConsistentWithTwoSplits(): Number trees consistent two splits. LnTreesConsistentWithTwoSplits(): Natural logarithm TreesConsistentWithTwoSplits(). Log2TreesConsistentWithTwoSplits(): Base two logarithm TreesConsistentWithTwoSplits(). Log2TreesConsistentWithTwoSplits(): Base 2 logarithm TreesConsistentWithTwoSplits().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shared information content of two splits — SplitSharedInformation","text":"Meila M (2007). “Comparing clusterings—information based distance.” Journal Multivariate Analysis, 98(5), 873–895. doi:10.1016/j.jmva.2006.11.013 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Shared information content of two splits — SplitSharedInformation","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitSharedInformation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shared information content of two splits — SplitSharedInformation","text":"","code":"# Eight leaves, labelled A to H.   # Split 1: ABCD|EFGH   # Split 2: ABC|DEFGH   # Let A1 = ABCD (four taxa), and A2 = ABC (three taxa).   # A1 and A2 overlap (both contain ABC).      TreesConsistentWithTwoSplits(n = 8, A1 = 4, A2 = 3) #> [1] 45   SplitSharedInformation(n = 8, A1 = 4, A2 = 3) #> [1] 2.722466   SplitDifferentInformation(n = 8, A1 = 4, A2 = 3) #> [1] 5.129283    # If splits are identical, then their shared information is the same   # as the information of either split:   SplitSharedInformation(n = 8, A1 = 3, A2 = 3) #> [1] 5.044394   TreeTools::SplitInformation(3, 5) #> [1] 5.044394"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":null,"dir":"Reference","previous_headings":"","what":"Are splits compatible? — SplitsCompatible","title":"Are splits compatible? — SplitsCompatible","text":"Determine whether splits compatible (concave); .e. can occur single tree.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are splits compatible? — SplitsCompatible","text":"","code":"SplitsCompatible(split1, split2)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are splits compatible? — SplitsCompatible","text":"split1, split2 Logical vectors listing leaves consistent order, identifying leaf member ingroup (TRUE) outgroup (FALSE) split question.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are splits compatible? — SplitsCompatible","text":"SplitsCompatible() returns logical specifying whether splits provided compatible one another.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Are splits compatible? — SplitsCompatible","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/SplitsCompatible.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are splits compatible? — SplitsCompatible","text":"","code":"A <- TRUE B <- FALSE SplitsCompatible(c(A, A, A, B, B, B),                  c(A, A, B, B, B, B)) #> [1] TRUE SplitsCompatible(c(A, A, A, B, B, B),                  c(A, A, B, B, B, A)) #> [1] FALSE"},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distances in parallel — StartParallel","title":"Calculate distances in parallel — StartParallel","text":"Accelerate distance calculation employing multiple CPU workers.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distances in parallel — StartParallel","text":"","code":"StartParallel(...)  SetParallel(cl)  GetParallel(cl)  StopParallel(quietly = FALSE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distances in parallel — StartParallel","text":"... Parameters pass makeCluster(). cl existing cluster. quietly Logical; TRUE, warn cluster running.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distances in parallel — StartParallel","text":"StartParallel() SetParallel() return previous value options(\"TreeDist-cluster\"). GetParallel() returns currently specified cluster. StopParallel() returns TRUE cluster destroyed, FALSE otherwise.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate distances in parallel — StartParallel","text":"\"TreeDist\" parallelizes calculation tree tree distances via parCapply() function, using user-defined cluster specified options(\"TreeDist-cluster\"). StartParallel() calls parallel::makeCluster() tells \"TreeDist\" use created cluster. SetParallel() tells \"TreeDist\" use pre-existing user-specified cluster. StopParallel() stops current TreeDist cluster.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate distances in parallel — StartParallel","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/StartParallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distances in parallel — StartParallel","text":"","code":"if (interactive()) { # Only run in terminal   library(\"TreeTools\", quietly = TRUE)   nCores <- ceiling(parallel::detectCores() / 2)   StartParallel(nCores) # Takes a few seconds to set up processes   GetParallel()   ClusteringInfoDistance(as.phylo(0:6, 100))   StopParallel() # Returns system resources }"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":null,"dir":"Reference","previous_headings":"","what":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"'TreeDist' R package implements suite metrics quantify topological distance pairs unweighted phylogenetic trees. also includes simple \"Shiny\" application allow visualization distance-based tree spaces, functions calculate information content trees splits.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"\"TreeDist\" primarily employs metrics category \"generalized Robinson–Foulds distances\": based comparing splits (bipartitions) trees, thus reflect relationship data within trees, reference branch lengths. Detailed documentation usage instructions available online vignettes.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":"generalized-rf-distances","dir":"Reference","previous_headings":"","what":"Generalized RF distances","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"Robinson–Foulds distance simply tallies number non-trivial splits (sometimes inaccurately termed clades, nodes edges) occur trees – splits perfectly identical contributes one point distance score zero, however similar different . overlooking potential similarities almost-identical splits, conservative approach undesirable properties. \"Generalized\" RF metrics generate matchings pair split one tree similar split . pair splits assigned similarity score; sum scores optimal matching quantifies similarity two trees. Different ways calculating similarity pair splits lead different tree distance metrics, implemented functions : MutualClusteringInfo(), SharedPhylogeneticInfo() Smith (2020) scores matchings based amount information one partition contains .  Mutual Phylogenetic Information assigns zero similarity split pairs exist single tree; Mutual Clustering Information metric forgiving, exhibits desirable behaviour; recommended metric tree comparison. (complement, ClusteringInfoDistance(), returns tree distance.) NyeSimilarity() Nye et al. (2006) score matchings according size largest split consistent , normalized Jaccard index.  approach extended Böcker et al. (2013) Jaccard–Robinson–Foulds metric (function JaccardRobinsonFoulds()). MatchingSplitDistance() Bogdanowicz Giaro (2012)  Lin et al. (2012) independently proposed counting number \"mismatched\" leaves pair splits. MatchingSplitInfoDistance() provides information-based equivalent (Smith 2020). package also implements variation path distance proposed Kendal Colijn (2016) (function KendallColijn()), approximations Nearest-Neighbour Interchange (NNI) distance (function NNIDist(); following Li et al. (1996)), calculates size (function MASTSize()) information content (function MASTInfo()) Maximum Agreement Subtree. implementation Tree Bisection Reconnection (TBR) distance, see package 'TBRDist'.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":"tree-space-analysis","dir":"Reference","previous_headings":"","what":"Tree space analysis","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"Map tree spaces readily visualize mapped landscapes, avoiding common analytical pitfalls (Smith, forthcoming), using inbuilt graphical user interface:   Serious analysts consult vignette command-line interface.","code":"TreeDist::MapTrees()"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"Böcker S, Canzar S, Klau GW (2013). “generalized Robinson-Foulds metric.” Darling , Stoye J (eds.), Algorithms Bioinformatics. WABI 2013. Lecture Notes Computer Science, vol 8126, 156–169. Springer, Berlin, Heidelberg. doi:10.1007/978-3-642-40453-5_13 . Bogdanowicz D, Giaro K (2012). “Matching split distance unrooted binary phylogenetic trees.” IEEE/ACM Transactions Computational Biology Bioinformatics, 9(1), 150–160. doi:10.1109/TCBB.2011.48 . Kendall M, Colijn C (2016). “Mapping phylogenetic trees reveal distinct patterns evolution.” Molecular Biology Evolution, 33(10), 2735–2743. doi:10.1093/molbev/msw124 . Li M, Tromp J, Zhang L (1996). “notes nearest neighbour interchange distance.” Goos G, Hartmanis J, Leeuwen J, Cai J, Wong CK (eds.), Computing Combinatorics, volume 1090, 343–351. Springer, Berlin, Heidelberg. ISBN 978-3-540-61332-9 978-3-540-68461-9, doi:10.1007/3-540-61332-3_168 . Lin Y, Rajan V, Moret BME (2012). “metric phylogenetic trees based matching.” IEEE/ACM Transactions Computational Biology Bioinformatics, 4(9), 1014–1022. doi:10.1109/TCBB.2011.157 . Nye TMW, Liò P, Gilks WR (2006). “novel algorithm web-based tool comparing two alternative phylogenetic trees.” Bioinformatics, 22(1), 117–119. doi:10.1093/bioinformatics/bti720 . Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 . Smith MR (2022). “Robust analysis phylogenetic tree space.” Systematic Biology, 71(5), 1255–1270. doi:10.1093/sysbio/syab100 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDist-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"TreeDist: Distances between Phylogenetic Trees — TreeDist-package","text":"Maintainer: Martin R. Smith martin.smith@durham.ac.uk (ORCID) [copyright holder, programmer] contributors: Roy Jonker roy_jonker@magiclogic.com [programmer, copyright holder] Yong Yang yongyanglink@gmail.com [contributor, copyright holder] Yi Cao [contributor, copyright holder]","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a simple tree — TreeDistPlot","title":"Plot a simple tree — TreeDistPlot","text":"Convenience plotting function used vignettes documentation.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a simple tree — TreeDistPlot","text":"","code":"TreeDistPlot(   tr,   title = NULL,   bold = NULL,   leaveRoom = FALSE,   prune = integer(0),   graft = integer(0),   edge.color = \"black\",   edge.width = NULL,   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a simple tree — TreeDistPlot","text":"tr tree class phylo, leaves labelled integers. title main title plot. bold Integer specifying leaves print bold. leaveRoom Logical specifying whether leave space print tree distances beneath plotted tree. prune, graft Integer vectors specifying edges highlight pruned grafted. edge.color Additional parameter plot.phylo; overridden prune graft requested. edge.width, ... Additional parameters plot.phylo.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistPlot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a simple tree — TreeDistPlot","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Information-based generalized Robinson–Foulds distances — TreeDistance","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"Calculate tree similarity distance measures based amount phylogenetic clustering information two trees hold common, proposed Smith (2020).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"","code":"TreeDistance(tree1, tree2 = NULL)  SharedPhylogeneticInfo(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE,   diag = TRUE )  DifferentPhylogeneticInfo(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE )  PhylogeneticInfoDistance(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE )  ClusteringInfoDistance(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE )  ExpectedVariation(tree1, tree2, samples = 10000)  MutualClusteringInfo(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE,   diag = TRUE )  SharedPhylogeneticInfoSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )  MutualClusteringInfoSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )  MatchingSplitInfo(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE,   diag = TRUE )  MatchingSplitInfoDistance(   tree1,   tree2 = NULL,   normalize = FALSE,   reportMatching = FALSE )  MatchingSplitInfoSplits(   splits1,   splits2,   nTip = attr(splits1, \"nTip\"),   reportMatching = FALSE )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"tree1, tree2 Trees class phylo, leaves labelled identically, lists trees undergo pairwise comparison.  implemented, tree2 = NULL compute distances pair trees list tree1 using fast algorithm based Day (1985) . normalize numeric value provided, used maximum value rescale results. TRUE, results rescaled maximum value calculated specified tree sizes topology, specified \"Normalization\" section . FALSE, results rescaled. reportMatching Logical specifying whether return clade matchings attribute score. diag Logical specifying whether return similarities along diagonal, .e. tree .  Applies tree2 list identical tree1, NULL. samples Integer specifying many samplings obtain; accuracy estimate increases sqrt(samples). splits1, splits2 Logical matrices row corresponds leaf, either listed order bearing identical names (sequence), column corresponds split, leaf identified member ingroup (TRUE) outgroup (FALSE) respective split. nTip (Optional) Integer specifying number leaves split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"reportMatching = FALSE, functions return numeric vector specifying requested similarities differences. reportMatching = TRUE, functions additionally return integer vector listing index split tree2 matched split tree1 optimal matching. Unmatched splits denoted NA. Use VisualizeMatching() plot optimal matching. TreeDistance() simply returns clustering information distance (alias ClusteringInfoDistance()).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"Generalized Robinson–Foulds distances calculate tree similarity finding optimal matching similarity split one tree pair second, considering possible ways pair splits trees (including leaving split unpaired). methods implemented use concepts entropy information (MacKay 2003)  assign similarity score pair splits. returned tree similarity measures state amount information, bits, splits two trees hold common optimally matched, following Smith (2020) . complementary tree distance measures state much information different splits two trees, optimal matching. trees contain different tips, tips present one tree removed comparison (definition, trees neither hold information common differ regarding tips).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"concepts-of-information","dir":"Reference","previous_headings":"","what":"Concepts of information","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"phylogenetic (Shannon) information content entropy split defined separate vignette. Using mutual (clustering) information (Meila 2007; Vinh et al. 2010)  two splits quantify similarity gives rise Mutual Clustering Information measure (MutualClusteringInfo(), MutualClusteringInfoSplits()); entropy distance gives Clustering Information Distance (ClusteringInfoDistance()). approach optimal many regards, implemented normalization convenience function TreeDistance(). Using amount phylogenetic information common two splits measure similarity gives rise Shared Phylogenetic Information similarity measure (SharedPhylogeneticInfo(), SharedPhylogeneticInfoSplits()). amount information distinct pair splits provides complementary Different Phylogenetic Information distance metric (DifferentPhylogeneticInfo()). Matching Split Information measure (MatchingSplitInfo(), MatchingSplitInfoSplits()) defines similarity pair splits phylogenetic information content informative split consistent input splits; MatchingSplitInfoDistance() corresponding measure tree difference. (information .)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"conversion-to-distances","dir":"Reference","previous_headings":"","what":"Conversion to distances","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"convert similarity measures distances, necessary subtract similarity score maximum value.  order generate distance metrics, functions subtract similarity twice total information content (SPI, MSI) entropy (MCI) splits trees (Smith 2020) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"normalization","dir":"Reference","previous_headings":"","what":"Normalization","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"normalize = TRUE, results rescaled distance ranges zero (principle) one. maximum distance sum information content entropy split tree; maximum similarity half value. (See Vinh et al. (2010, table 3) Smith (2020)  alternative normalization possibilities.) Note distance value one (= similarity zero) seldom achieved, even different trees exhibit similarity. may thus helpful rescale normalized value expected distance random pair trees equals one.  can calculated ExpectedVariation(); see package 'TreeDistData' compilation expected values different metrics trees 200 leaves. Alternatively, use normalize = pmax pmin scale information content entropy splits (pmax) least (pmin) informative tree pair. calculate relative similarity reference tree known \"correct\", use normalize = SplitwiseInfo(trueTree) (SPI, MSI) ClusteringEntropy(trueTree) (MCI). worked examples, see internal function NormalizeInfo(), called distance functions parameter = normalize. .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"distances-between-large-trees","dir":"Reference","previous_headings":"","what":"Distances between large trees","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"balance memory demands runtime flexibility, functions implemented trees 2048 leaves. analyse trees 8192 leaves, need modified version package: install.packages(\"BigTreeDist\", repos = \"https://ms609.github.io/packages/\") Use library(\"BigTreeDist\") instead library(\"TreeDist\") load modified package – prefix functions package name, e.g. BigTreeDist::TreeDistance(). alternative download method, uninstall TreeDist TreeTools using remove.packages(), use devtools::install_github(\"ms609/TreeTools\", ref = \"-leaves\") install modified TreeTools package; , install TreeDist using devtools::install_github(\"ms609/TreeDist\", ref = \"-leaves\"). (TreeDist need building source modified TreeTools package installed, code links values set TreeTools source code.) Trees 8192 leaves require modification source code, maintainer plans attempt future; please comment GitHub find useful.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"Day WHE (1985). “Optimal algorithms comparing trees labeled leaves.” Journal Classification, 2(1), 7–28. doi:10.1007/BF01908061 . MacKay DJC (2003). Information Theory, Inference, Learning Algorithms. Cambridge University Press, Cambridge. https://www.inference.org.uk/itprnn/book.pdf. Meila M (2007). “Comparing clusterings—information based distance.” Journal Multivariate Analysis, 98(5), 873–895. doi:10.1016/j.jmva.2006.11.013 . Smith MR (2020). “Information theoretic Generalized Robinson-Foulds metrics comparing phylogenetic trees.” Bioinformatics, 36(20), 5007–5013. doi:10.1093/bioinformatics/btaa614 . Vinh NX, Epps J, Bailey J (2010). “Information theoretic measures clusterings comparison: variants, properties, normalization correction chance.” Journal Machine Learning Research, 11, 2837–2854. doi:10.1145/1553374.1553511 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeDistance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information-based generalized Robinson–Foulds distances — TreeDistance","text":"","code":"tree1 <- ape::read.tree(text=\"((((a, b), c), d), (e, (f, (g, h))));\") tree2 <- ape::read.tree(text=\"(((a, b), (c, d)), ((e, f), (g, h)));\") tree3 <- ape::read.tree(text=\"((((h, b), c), d), (e, (f, (g, a))));\")  # Best possible score is obtained by matching a tree with itself DifferentPhylogeneticInfo(tree1, tree1) # 0, by definition #> [1] 0 SharedPhylogeneticInfo(tree1, tree1) #> [1] 22.53747 SplitwiseInfo(tree1) # Maximum shared phylogenetic information #> [1] 22.53747  # Best possible score is a function of tree shape; the splits within # balanced trees are more independent and thus contain less information SplitwiseInfo(tree2) #> [1] 19.36755  # How similar are two trees? SharedPhylogeneticInfo(tree1, tree2) # Amount of phylogenetic information in common #> [1] 13.75284 attr(SharedPhylogeneticInfo(tree1, tree2, reportMatching = TRUE), \"matching\") #> [1] 1 4 2 3 5 VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2) # Which clades are matched?   DifferentPhylogeneticInfo(tree1, tree2) # Distance measure #> [1] 14.39934 DifferentPhylogeneticInfo(tree2, tree1) # The metric is symmetric #> [1] 14.39934  # Are they more similar than two trees of this shape would be by chance? ExpectedVariation(tree1, tree2, sample=12)[\"DifferentPhylogeneticInfo\", \"Estimate\"] #> [1] 34.5706  # Every split in tree1 conflicts with every split in tree3 # Pairs of conflicting splits contain clustering, but not phylogenetic,  # information SharedPhylogeneticInfo(tree1, tree3) # = 0 #> [1] 0 MutualClusteringInfo(tree1, tree3) # > 0 #> [1] 0.6539805  # Distance functions internally convert trees to Splits objects. # Pre-conversion can reduce run time if the same trees will feature in # multiple comparisons splits1 <- TreeTools::as.Splits(tree1) splits2 <- TreeTools::as.Splits(tree2)  SharedPhylogeneticInfoSplits(splits1, splits2) #> [1] 13.75284 MatchingSplitInfoSplits(splits1, splits2) #> [1] 17.09254 MutualClusteringInfoSplits(splits1, splits2) #> [1] 3.031424"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Information content of splits within a tree — TreeInfo","title":"Information content of splits within a tree — TreeInfo","text":"Sum entropy (ClusteringEntropy()), clustering information content (ClusteringInfo()), phylogenetic information content (SplitwiseInfo()) across split within phylogenetic tree, consensus set phylogenetic trees (ConsensusInfo()). value greater total information content tree tree contains multiple splits, splits independent thus contain mutual information counted ","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information content of splits within a tree — TreeInfo","text":"","code":"SplitwiseInfo(x, p = NULL, sum = TRUE)  ClusteringEntropy(x, p = NULL, sum = TRUE)  ClusteringInfo(x, p = NULL, sum = TRUE)  # S3 method for class 'phylo' ClusteringEntropy(x, p = NULL, sum = TRUE)  # S3 method for class 'list' ClusteringEntropy(x, p = NULL, sum = TRUE)  # S3 method for class 'multiPhylo' ClusteringEntropy(x, p = NULL, sum = TRUE)  # S3 method for class 'Splits' ClusteringEntropy(x, p = NULL, sum = TRUE)  # S3 method for class 'phylo' ClusteringInfo(x, p = NULL, sum = TRUE)  # S3 method for class 'list' ClusteringInfo(x, p = NULL, sum = TRUE)  # S3 method for class 'multiPhylo' ClusteringInfo(x, p = NULL, sum = TRUE)  # S3 method for class 'Splits' ClusteringInfo(x, p = NULL, sum = TRUE)  ConsensusInfo(trees, info = \"phylogenetic\", p = 0.5, check.tips = TRUE)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information content of splits within a tree — TreeInfo","text":"x tree class phylo, list trees, multiPhylo object. p Scalar 0.5 1 specifying minimum proportion trees must contain split appear within consensus. sum Logical: TRUE, sum information content split provide total splitwise information content tree. trees List phylo objects, optionally class multiPhylo. info Abbreviation \"phylogenetic\" \"clustering\", specifying concept information employ. check.tips Logical specifying whether renumber leaves leaf numbering consistent trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information content of splits within a tree — TreeInfo","text":"SplitwiseInfo(), ClusteringInfo() ClusteringEntropy() return splitwise information content tree – split turn, sum = FALSE – bits. ConsensusInfo() returns splitwise information content majority rule consensus trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"clustering-information","dir":"Reference","previous_headings":"","what":"Clustering information","title":"Information content of splits within a tree — TreeInfo","text":"Clustering entropy addresses question \"much information contained splits within tree\". approach complementary phylogenetic information content, used SplitwiseInfo(). essence, asks, given split subdivides leaves tree two partitions, easy predict partition randomly drawn leaf belongs (Meila2007; Vinh et al. 2010) . Formally, entropy split S divides n leaves two partitions sizes b given H(S) = - /n log /n - b/n log b/n. Base 2 logarithms conventionally used, entropy measured bits. Entropy denotes number bits necessary encode outcome random variable: , random variable \"partition randomly selected leaf belong \". even split entropy 1 bit: better way encoding outcome using one bit specify two partitions randomly selected leaf belongs . uneven split lower entropy: membership larger partition common, thus less surprising; can signified using fewer bits optimal compression system. sounds confusing, consider creating code transmit cluster label two randomly selected leaves.  One straightforward option use 00 = \"leaves belong partition \" 11 = \"leaves belong partition B\" 01 = 'First leaf , second B` 10 = 'First leaf B, second ` code uses two bits transmit partition labels two leaves. partitions B equiprobable, optimal code; entropy – average information content required per leaf – 1 bit. Alternatively, use (suboptimal) code 0 = \"leaves belong partition \" 111 = \"leaves belong partition B\" 101 = 'First leaf , second B` 110 = 'First leaf B, second ` much larger B, pairs leaves require just single bit (code 0). additional bits 1+ leaf belongs B may required sufficiently rarely average message requires fewer two bits two leaves, entropy less 1 bit.  (optimal coding strategy depend exact sizes B.) entropy measures bits required transmit cluster label leaf (Vinh2010: p. 2840) , information content split entropy multiplied number leaves.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"phylogenetic-information","dir":"Reference","previous_headings":"","what":"Phylogenetic information","title":"Information content of splits within a tree — TreeInfo","text":"Phylogenetic information expresses information content split terms probability uniformly selected tree contain (Thorley et al. 1998) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"consensus-information","dir":"Reference","previous_headings":"","what":"Consensus information","title":"Information content of splits within a tree — TreeInfo","text":"information content splits consensus tree calculated interpreting support values (.e. proportion trees containing split consensus) probabilities true tree contains split, following Smith (2022) .","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Information content of splits within a tree — TreeInfo","text":"Smith MR (2022). “Using information theory detect rogue taxa improve consensus trees.” Systematic Biology, syab099. doi:10.1093/sysbio/syab099 . Thorley JL, Wilkinson M, Charleston M (1998). “information content consensus trees.” Rizzi , Vichi M, Bock H (eds.), Advances Data Science Classification, 91–98. Springer, Berlin. doi:10.1007/978-3-642-72253-0_12 . Vinh NX, Epps J, Bailey J (2010). “Information theoretic measures clusterings comparison: variants, properties, normalization correction chance.” Journal Machine Learning Research, 11, 2837–2854. doi:10.1145/1553374.1553511 .","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Information content of splits within a tree — TreeInfo","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/TreeInfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information content of splits within a tree — TreeInfo","text":"","code":"library(\"TreeTools\", quietly = TRUE)  SplitwiseInfo(PectinateTree(8)) #> [1] 22.53747 tree <- read.tree(text = \"(a, b, (c, (d, e, (f, g)0.8))0.9);\") SplitwiseInfo(tree) #> [1] 10.73217 SplitwiseInfo(tree, TRUE) #> [1] 8.641244  # Clustering entropy of an even split = 1 bit ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 4), rep(FALSE, 4)))) #> [1] 1  # Clustering entropy of an uneven split < 1 bit ClusteringEntropy(TreeTools::as.Splits(c(rep(TRUE, 2), rep(FALSE, 6)))) #> [1] 0.8112781  tree1 <- TreeTools::BalancedTree(8) tree2 <- TreeTools::PectinateTree(8)  ClusteringInfo(tree1) #> [1] 33.9609 ClusteringEntropy(tree1) #> [1] 4.245112 ClusteringInfo(list(one = tree1, two = tree2)) #>      one      two  #> 33.96090 36.25139   ClusteringInfo(tree1) + ClusteringInfo(tree2) #> [1] 70.21229 ClusteringEntropy(tree1) + ClusteringEntropy(tree2) #> [1] 8.776537 ClusteringInfoDistance(tree1, tree2) #> [1] 2.713688 MutualClusteringInfo(tree1, tree2) #> [1] 3.031424  # Clustering entropy with uncertain splits tree <- ape::read.tree(text = \"(a, b, (c, (d, e, (f, g)0.8))0.9);\") ClusteringInfo(tree) #> [1] 18.98028 ClusteringInfo(tree, TRUE) #> [1] 17.16773  # Support-weighted information content of a consensus tree set.seed(0) trees <- list(RandomTree(8), RootTree(BalancedTree(8), 1), PectinateTree(8)) cons <- consensus(trees, p = 0.5) p <- SplitFrequency(cons, trees) / length(trees) plot(cons) LabelSplits(cons, signif(SplitwiseInfo(cons, p, sum = FALSE), 4)) ConsensusInfo(trees) #> [1] 7.080254 LabelSplits(cons, signif(ClusteringInfo(cons, p, sum = FALSE), 4))  ConsensusInfo(trees, \"clustering\") #> [1] 18.31378"},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a matching — VisualizeMatching","title":"Visualize a matching — VisualizeMatching","text":"Depict splits matched two trees using specified Generalized Robinson–Foulds similarity measure.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a matching — VisualizeMatching","text":"","code":"VisualizeMatching(   Func,   tree1,   tree2,   setPar = TRUE,   precision = 3L,   Plot = plot.phylo,   matchZeros = TRUE,   plainEdges = FALSE,   edge.cex = par(\"cex\"),   value.cex = edge.cex * 0.8,   edge.frame = \"rect\",   edge.width = 1,   edge.color = \"black\",   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a matching — VisualizeMatching","text":"Func Function used construct tree similarity. tree1, tree2 Trees class phylo, identical leaf labels. setPar Logical specifying whether graphical parameters set display trees side side. precision Integer specifying number significant figures display reporting matching scores. Plot Function use plot trees. matchZeros Logical specifying whether pair splits zero similarity (TRUE), leave unpaired (FALSE). plainEdges Logical specifying whether plot edges uniform width colour (TRUE), whether draw edge widths according similarity associated splits (FALSE). edge.cex Character expansion edge labels. FALSE, suppress edge labels. value.cex Character expansion values edge labels. FALSE, values displayed. edge.frame Character specifying kind frame printed around text edge labels.  Choose abbreviation \"rect\", \"circle\", \"none\". edge.width, edge.color, ... Additional parameters send Plot().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a matching — VisualizeMatching","text":"VisualizeMatching() invisibly returns matching splits tree1 tree2 (.e. Func(tree1, tree2, reportMatching = TRUE))","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a matching — VisualizeMatching","text":"Note visualizing Robinson–Foulds distance (using Func = RobinsonFouldsMatching), matched splits assigned similarity score 1, deducted total number splits calculate Robinson–Foulds distance.  Unmatched splits thus contribute one total tree distance.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a matching — VisualizeMatching","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/VisualizeMatching.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a matching — VisualizeMatching","text":"","code":"tree1 <- TreeTools::BalancedTree(6) tree2 <- TreeTools::PectinateTree(6)  VisualizeMatching(RobinsonFouldsMatching, tree1, tree2)  matching <- VisualizeMatching(SharedPhylogeneticInfo, tree1, tree2,                               matchZeros = FALSE)  attributes(matching) #> $matching #> [1] 2 1 3 #>  #> $matchedSplits #> [1] \"t1 t2 t3 | t4 t5 t6 => t4 t5 t6 | t1 t2 t3\" #> [2] \"t1 t2 | t3 t4 t5 t6 => t3 t4 t5 t6 | t1 t2\" #> [3] \"t4 t5 | t1 t2 t3 t6 .. t5 t6 | t1 t2 t3 t4\" #>  #> $matchedScores #> [1] 3.544321 2.807355 0.000000 #>  #> $pairScores #>           [,1]     [,2]      [,3] #> [1,] 1.2223924 3.544321 1.2223924 #> [2,] 2.8073549 1.222392 0.4854268 #> [3,] 0.4854268 1.222392 0.0000000 #>"},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster size statistics — cluster-statistics","title":"Cluster size statistics — cluster-statistics","text":"Cluster size statistics","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster size statistics — cluster-statistics","text":"","code":"SumOfRanges(x, cluster = 1)  SumOfVariances(x, cluster = 1)  SumOfVars(x, cluster = 1)  MeanCentroidDistance(x, cluster = 1, Average = mean)  MeanCentDist(x, cluster = 1, Average = mean)  MeanCentroidDist(x, cluster = 1, Average = mean)  DistanceFromMedian(x, cluster = 1, Average = mean)  DistFromMed(x, cluster = 1, Average = mean)  MeanNN(x, cluster = 1, Average = mean)  MeanMSTEdge(x, cluster = 1)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster size statistics — cluster-statistics","text":"x Matrix row lists coordinates point Euclidian space; , supported, dist object specifying distances pair points. cluster Optional integer vector specifying cluster group row x belongs. Average Function use summarize distances. Defaults mean; specifying median returns value akin median absolute divergence (see mad).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster size statistics — cluster-statistics","text":"SumOfRanges() returns numeric specifying sum ranges within cluster across dimensions. SumOfVariances() returns numeric specifying sum variances within cluster across dimensions. MeanCentroidDistance() returns numeric specifying mean distance centroid points cluster. DistanceFromMedian() returns numeric specifying mean distance point (except median) median point cluster. MeanNN() returns numeric specifying mean distance point within cluster nearest neighbour. MeanMSTEdge() returns numeric specifying mean length edge minimum spanning tree points within cluster.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster size statistics — cluster-statistics","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/cluster-statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster size statistics — cluster-statistics","text":"","code":"points <- rbind(matrix(1:16, 4), rep(1, 4), matrix(1:32, 8, 4) / 10) cluster <- rep(1:3, c(4, 1, 8))  plot(   points[, 1:2], # Plot first two dimensions of four-dimensional space   col = cluster, pch = cluster, # Style by cluster membership   asp = 1, # Fix aspect ratio to avoid distortion   ann = FALSE, frame = FALSE # Simple axes )   SumOfRanges(points, cluster) #> [1] 12.0  0.0  2.8 SumOfVariances(points, cluster) #> [1] 6.666667       NA 0.240000 MeanCentroidDistance(points, cluster) #> [1] 2.0 0.0 0.4 DistanceFromMedian(points, cluster) #> [1] 2.6666667        NA 0.4571429 MeanNN(points, cluster) #> [1] 2.0  NA 0.2 MeanMSTEdge(points, cluster) #> [1] 2.0  NA 0.2"},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-MASTSizeEdges.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate MAST size from edge matrices. — .MASTSizeEdges","title":"Calculate MAST size from edge matrices. — .MASTSizeEdges","text":"Internal function.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-MASTSizeEdges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate MAST size from edge matrices. — .MASTSizeEdges","text":"","code":".MASTSizeEdges(edge1, edge2, nTip)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-MASTSizeEdges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate MAST size from edge matrices. — .MASTSizeEdges","text":"edge1 Edge matrix tree 1. Must postorder! edge2 Edge matrix tree 2. nTip Integer specifying number leaves split.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-PairMean.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean of two numbers — .PairMean","title":"Mean of two numbers — .PairMean","text":"Used normalization range calculation","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-PairMean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean of two numbers — .PairMean","text":"","code":".PairMean(x, y)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-TreeDistance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distance between trees, or lists of trees — .TreeDistance","title":"Calculate distance between trees, or lists of trees — .TreeDistance","text":"Calculate distance trees, lists trees","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-TreeDistance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distance between trees, or lists of trees — .TreeDistance","text":"","code":".TreeDistance(Func, tree1, tree2, checks = TRUE, ...)"},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-TreeDistance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distance between trees, or lists of trees — .TreeDistance","text":"checks Logical specifying whether perform basic sanity checks avoid crashes C++.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/dot-TreeDistance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate distance between trees, or lists of trees — .TreeDistance","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Median of a set of trees — median.multiPhylo","title":"Median of a set of trees — median.multiPhylo","text":"Calculate single binary tree represents geometric median – \"average\" – forest tree topologies.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Median of a set of trees — median.multiPhylo","text":"","code":"# S3 method for class 'multiPhylo' median(   x,   na.rm = FALSE,   Distance = ClusteringInfoDistance,   index = FALSE,   breakTies = TRUE,   ... )"},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Median of a set of trees — median.multiPhylo","text":"x Object class multiPhylo containing phylogenetic trees. na.rm, ... Unused; included consistency default function.. Distance Function calculate distances pair trees x. index Logical: TRUE, return index median tree(s); FALSE, return tree . breakTies Logical: TRUE, return single tree minimum score; FALSE, return tied trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Median of a set of trees — median.multiPhylo","text":"median() returns object class phylo corresponding geometric median set trees: , tree whose average distance trees set lowest. multiple trees tie average distance, first returned, unless breakTies = FALSE, case object class multiPhylo containing trees returned.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Median of a set of trees — median.multiPhylo","text":"geometric median tree exhibits shortest average distance tree topology set. represents \"average\" set trees, though note unsampled tree may closer geometric \"centre gravity\" input set – tree considered. result depend metric chosen calculate distances tree topologies. absence natural metric tree topologies, default choice ClusteringInfoDistance() – discards branch length information. specifying different function, sure returns difference, rather similarity.","code":""},{"path":[]},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Median of a set of trees — median.multiPhylo","text":"Martin R. Smith (martin.smith@durham.ac.uk)","code":""},{"path":"https://ms609.github.io/TreeDist/dev/reference/median.multiPhylo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Median of a set of trees — median.multiPhylo","text":"","code":"library(\"TreeTools\", quietly = TRUE) tenTrees <- as.phylo(1:10, nTip = 8)  # Default settings: median(tenTrees) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # Robinson-Foulds distances include ties: median(tenTrees, Distance = RobinsonFoulds, breakTies = FALSE) #> 4 phylogenetic trees  # Be sure to use a distance function, rather than a similarity: NyeDistance <- function(...) NyeSimilarity(..., similarity = FALSE) median(tenTrees, Distance = NyeDistance) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length.  # To analyse a list of trees that is not of class multiPhylo: treeList <- lapply(1:10, as.phylo, nTip = 8) class(treeList) #> [1] \"list\" median(structure(treeList, class = \"multiPhylo\")) #>  #> Phylogenetic tree with 8 tips and 7 internal nodes. #>  #> Tip labels: #>   t1, t2, t3, t4, t5, t6, ... #>  #> Rooted; no branch length."},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-2929000-development","dir":"Changelog","previous_headings":"","what":"TreeDist 2.9.2.9000 (development)","title":"TreeDist 2.9.2.9000 (development)","text":"C++ source formatting. Discontinue tests R 3.6 4.0.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-292-2025-01-11","dir":"Changelog","previous_headings":"","what":"TreeDist 2.9.2 (2025-01-11)","title":"TreeDist 2.9.2 (2025-01-11)","text":"CRAN release: 2025-01-11 Fix crash calculating NNI distance large trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-291-2024-09-05","dir":"Changelog","previous_headings":"","what":"TreeDist 2.9.1 (2024-09-05)","title":"TreeDist 2.9.1 (2024-09-05)","text":"CRAN release: 2024-09-07 Avoid false positive MKL testing environment.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-290-2024-09-03","dir":"Changelog","previous_headings":"","what":"TreeDist 2.9.0 (2024-09-03)","title":"TreeDist 2.9.0 (2024-09-03)","text":"CRAN release: 2024-09-03 VisualizeMatching() allows control output format, returns matching (#124). DistanceFromMedian(Average = median) allows calculation MAD. SpectralEigens() returns correct eigenvalues (smallest overlooked). SpectralEigens() handles values nEig larger input. Anticipate new behaviour unlist(use.names = TRUE) R 4.5.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-280-2024-07-25","dir":"Changelog","previous_headings":"","what":"TreeDist 2.8.0 (2024-07-25)","title":"TreeDist 2.8.0 (2024-07-25)","text":"CRAN release: 2024-07-26 Islands() allows identification islands trees. Internal implementation path SPR distances, removing dependency phangorn (thus R 4.4). Add progress bar within .MaxValue()","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-271-2024-06-13","dir":"Changelog","previous_headings":"","what":"TreeDist 2.7.1 (2024-06-13)","title":"TreeDist 2.7.1 (2024-06-13)","text":"Documentation improvements. Fix KCDiameter.multiPhylo() multiple trees.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-270-2023-10-25","dir":"Changelog","previous_headings":"","what":"TreeDist 2.7.0 (2023-10-25)","title":"TreeDist 2.7.0 (2023-10-25)","text":"CRAN release: 2023-10-25 Fix calculation error StrainCol(). App: Display strain 3D tree space viewer. Support distances larger trees. Support unrooted trees VisualizeMatching() (#103).","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-263-2023-08-25","dir":"Changelog","previous_headings":"","what":"TreeDist 2.6.3 (2023-08-25)","title":"TreeDist 2.6.3 (2023-08-25)","text":"CRAN release: 2023-08-25 Fix bug comparing “multiPhylo” object containing single tree. Documentation clarification: finding non-matching leaves.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-262-2023-06-28","dir":"Changelog","previous_headings":"","what":"TreeDist 2.6.2 (2023-06-28)","title":"TreeDist 2.6.2 (2023-06-28)","text":"CRAN release: 2023-06-29 Support non-square matrices LAPJV().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-261-2023-04-25","dir":"Changelog","previous_headings":"","what":"TreeDist 2.6.1 (2023-04-25)","title":"TreeDist 2.6.1 (2023-04-25)","text":"CRAN release: 2023-05-01 StopParallel() gains quietly argument suppress unnecessary messages. Use “PlotTools” package spectrum legends. Minor documentation tweaks.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-260-2023-02-20","dir":"Changelog","previous_headings":"","what":"TreeDist 2.6.0 (2023-02-20)","title":"TreeDist 2.6.0 (2023-02-20)","text":"CRAN release: 2023-02-20 Support comparison trees different tips. Fix caching errors MapDist() (#98). Update tests compatibility ape 5.7.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-250-2022-10-07","dir":"Changelog","previous_headings":"","what":"TreeDist 2.5.0 (2022-10-07)","title":"TreeDist 2.5.0 (2022-10-07)","text":"CRAN release: 2022-10-07 New functions measure cluster sizes (see ?\"cluster-statistics\"). KMeansPP() conducts clustering using K-means++, replacing K-means app. New vignette tree landscape analysis.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-241-2022-07-20","dir":"Changelog","previous_headings":"","what":"TreeDist 2.4.1 (2022-07-20)","title":"TreeDist 2.4.1 (2022-07-20)","text":"CRAN release: 2022-07-20 New vignette compare tree sets. PathVector() now treats trees root node rooted. Fix plot layout treespace vignette. Informative failure enough memory consensus_info(). Replace throw stop C++.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-240-2022-03-23","dir":"Changelog","previous_headings":"","what":"TreeDist 2.4.0 (2022-03-23)","title":"TreeDist 2.4.0 (2022-03-23)","text":"CRAN release: 2022-03-23 Correct calculation trustworthiness continuity metrics. Depict strain minimum spanning trees StrainCol() helper function MSTSegments(). Update tests consistency “TreeTools” v1.7. Use lighter Rcpp headers.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-230-2022-01-04","dir":"Changelog","previous_headings":"","what":"TreeDist 2.3.0 (2022-01-04)","title":"TreeDist 2.3.0 (2022-01-04)","text":"CRAN release: 2022-01-03 Support ConsensusInfo(p > 0.5). Address hypervolume comparison vignettes. Support uniform manifold approximation projection app.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-220-2021-09-13","dir":"Changelog","previous_headings":"","what":"TreeDist 2.2.0 (2021-09-13)","title":"TreeDist 2.2.0 (2021-09-13)","text":"CRAN release: 2021-09-13 Speed improvements, using optimizations suggested Alexis Stamatakis’ Bioinformatics group. Support parallel computation via StartParallel(). Progress bars.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-211-2021-07-13","dir":"Changelog","previous_headings":"","what":"TreeDist 2.1.1 (2021-07-13)","title":"TreeDist 2.1.1 (2021-07-13)","text":"CRAN release: 2021-07-13 Solaris compatibility. Modest vignette improvements. spic/scic abbreviation recognition.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-210-2021-07-12","dir":"Changelog","previous_headings":"","what":"TreeDist 2.1.0 (2021-07-12)","title":"TreeDist 2.1.0 (2021-07-12)","text":"CRAN release: 2021-07-12","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"new-features-2-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"TreeDist 2.1.0 (2021-07-12)","text":"ConsensusInfo() quickly calculates splitwise information content consensus set trees, Smith (forthcoming). SplitwiseInfo() ClusteringInfo() gain p parameter reflect reduced information content splits lower support values, sum parameter allow return individual split information content. KCDiameter() approximates diameter Kendall-Colijn metric. Plot3() (experimental) provides pseudo-3D plotting.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"renamed-functions-2-1-0","dir":"Changelog","previous_headings":"","what":"Renamed functions","title":"TreeDist 2.1.0 (2021-07-12)","text":"Project()/ProjectionQuality() re-named MapTrees()/MappingQuality(). SpectralClustering() re-named SpectralEigens().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"improvements-2-1-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"TreeDist 2.1.0 (2021-07-12)","text":"Add self-organizing map example treespace vignette. Allow specification custom vectors Kendall–Colijn metric. Faster --tree distance calculation.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-203-2021-01-31","dir":"Changelog","previous_headings":"","what":"TreeDist 2.0.3 (2021-01-31)","title":"TreeDist 2.0.3 (2021-01-31)","text":"CRAN release: 2021-01-31 Diagnose fix memory leaks, including -long reported matchings. Explicitly import shiny/shinyjs functions.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-200-2021-01-20","dir":"Changelog","previous_headings":"","what":"TreeDist 2.0.0 (2021-01-20)","title":"TreeDist 2.0.0 (2021-01-20)","text":"CRAN release: 2021-01-20 Project() launches ‘shiny’ app projection analysis tree space. ProjectionQuality() calculates trustworthiness continuity tree space mappings. Faster calculation Robinson–Foulds distance (using algorithm Day (1985)) clustering information distance. New class ClusterTable allow faster distance computation Day (1985) algorithm. Improve error messages CalculateTreeDist(). Improvements vignettes. Use package ‘vdiffr’ conditionally.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-121-2020-09-17","dir":"Changelog","previous_headings":"","what":"TreeDist 1.2.1 (2020-09-17)","title":"TreeDist 1.2.1 (2020-09-17)","text":"CRAN release: 2020-09-17 Import RdMacros package ‘RdPack’.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-120-2020-08-28","dir":"Changelog","previous_headings":"","what":"TreeDist 1.2.0 (2020-08-28)","title":"TreeDist 1.2.0 (2020-08-28)","text":"CRAN release: 2020-08-28 TreeDistance() related functions now return dist object computing distances pairs trees list. Improve floating-point arithmetic TreeDistance() functions. TreeDistance() now returns distance (documented), rather similarity. Fix rounding error NNI ‘Li’ upper estimate, improve NNI performance. Reduce precision LAPJV rounding errors result interminable run times.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-111-2020-07-10","dir":"Changelog","previous_headings":"","what":"TreeDist 1.1.1 (2020-07-10)","title":"TreeDist 1.1.1 (2020-07-10)","text":"CRAN release: 2020-07-10 Fix range errors calculating tree distances.","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-110","dir":"Changelog","previous_headings":"","what":"TreeDist 1.1.0","title":"TreeDist 1.1.0","text":"Improvements NNIDist() light Fack et al. (2002). Add NNIDiameter(): approximate diameter NNI distance. Remove vignette ‘Interpreting tree distances’: duplicates https://ms609.github.io/TreeDistData/articles/09-expected-similarity.html. Remove redundant data object oneOverlap. Fix issue installing R 3.x (require C++11 ensure declaration UINT_FAST16_MAX). Fix memory-handling bug lapjv().","code":""},{"path":"https://ms609.github.io/TreeDist/dev/news/index.html","id":"treedist-100-2020-06-30","dir":"Changelog","previous_headings":"","what":"TreeDist 1.0.0 (2020-06-30)","title":"TreeDist 1.0.0 (2020-06-30)","text":"CRAN release: 2020-06-30 Initial release, building draft functions included ‘TreeSearch’ 0.3.2.9005.","code":""}]
